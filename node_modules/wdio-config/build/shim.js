'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hasWdioSyncSupport = exports.wrapCommand = exports.runFnInFiberContext = exports.runTestInFiberContext = exports.executeHooksWithArgs = undefined;

var _sourceMapSupport2 = require('source-map-support');

var _wdioLogger = require('wdio-logger');

var _wdioLogger2 = _interopRequireDefault(_wdioLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

(0, _sourceMapSupport2.install)();


const log = (0, _wdioLogger2.default)('wdio-config');
const NOOP = () => {};

let executeHooksWithArgs = exports.executeHooksWithArgs = (() => {
    var _ref = _asyncToGenerator(function* (hooks, args) {
        /**
         * make sure hooks are an array of functions
         */
        if (!Array.isArray(hooks)) {
            hooks = [hooks];
        }

        /**
         * make sure args is an array since we are calling apply
         */
        if (!Array.isArray(args)) {
            args = [args];
        }

        hooks = hooks.map(function (hook) {
            return new Promise(function (resolve) {
                let result;

                try {
                    result = hook.apply(null, args);
                } catch (e) {
                    log.error(e.stack);
                    return resolve();
                }

                /**
                 * if a promise is returned make sure we don't have a catch handler
                 * so in case of a rejection it won't cause the hook to fail
                 */
                if (result && typeof result.then === 'function') {
                    return result.then(resolve, function (e) {
                        log.error(e.stack);
                        resolve();
                    });
                }

                resolve(result);
            });
        });

        return Promise.all(hooks);
    });

    function executeHooksWithArgsShim(_x, _x2) {
        return _ref.apply(this, arguments);
    }

    return executeHooksWithArgsShim;
})();

let runTestInFiberContext = exports.runTestInFiberContext = NOOP;
let runFnInFiberContext = exports.runFnInFiberContext = (fn, done) => {
    return function (...args) {
        const result = fn.apply(this, args);

        if (typeof done === 'function') {
            return done(result);
        }

        return result;
    };
};
let wrapCommand = exports.wrapCommand = (_, origFn) => origFn;
let hasWdioSyncSupport = exports.hasWdioSyncSupport = false;

/**
 * shim to make sure that we only wrap commands if wdio-sync is installed as dependency
 */
try {
    // eslint-disable-next-line import/no-unresolved
    const wdioSync = require('wdio-sync');
    log.debug('wdio-sync found, running tests synchronous');

    exports.hasWdioSyncSupport = hasWdioSyncSupport = true;
    exports.runFnInFiberContext = runFnInFiberContext = wdioSync.runFnInFiberContext;
    exports.runTestInFiberContext = runTestInFiberContext = wdioSync.runTestInFiberContext;
    exports.wrapCommand = wrapCommand = wdioSync.wrapCommand;
    exports.executeHooksWithArgs = executeHooksWithArgs = wdioSync.executeHooksWithArgs;
} catch (e) {
    log.debug('wdio-sync not found, running tests asynchronous');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zaGltLmpzIl0sIm5hbWVzIjpbImxvZyIsIk5PT1AiLCJleGVjdXRlSG9va3NXaXRoQXJncyIsImhvb2tzIiwiYXJncyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImhvb2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdCIsImFwcGx5IiwiZSIsImVycm9yIiwic3RhY2siLCJ0aGVuIiwiYWxsIiwiZXhlY3V0ZUhvb2tzV2l0aEFyZ3NTaGltIiwicnVuVGVzdEluRmliZXJDb250ZXh0IiwicnVuRm5JbkZpYmVyQ29udGV4dCIsImZuIiwiZG9uZSIsIndyYXBDb21tYW5kIiwiXyIsIm9yaWdGbiIsImhhc1dkaW9TeW5jU3VwcG9ydCIsIndkaW9TeW5jIiwicmVxdWlyZSIsImRlYnVnIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxNQUFNLDBCQUFPLGFBQVAsQ0FBWjtBQUNBLE1BQU1DLE9BQU8sTUFBTSxDQUFFLENBQXJCOztBQUVPLElBQUlDO0FBQUEsaUNBQXVCLFdBQXlDQyxLQUF6QyxFQUFnREMsSUFBaEQsRUFBc0Q7QUFDcEY7OztBQUdBLFlBQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjSCxLQUFkLENBQUwsRUFBMkI7QUFDdkJBLG9CQUFRLENBQUNBLEtBQUQsQ0FBUjtBQUNIOztBQUVEOzs7QUFHQSxZQUFJLENBQUNFLE1BQU1DLE9BQU4sQ0FBY0YsSUFBZCxDQUFMLEVBQTBCO0FBQ3RCQSxtQkFBTyxDQUFDQSxJQUFELENBQVA7QUFDSDs7QUFFREQsZ0JBQVFBLE1BQU1JLEdBQU4sQ0FBVSxVQUFDQyxJQUFEO0FBQUEsbUJBQVUsSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBYTtBQUNqRCxvQkFBSUMsTUFBSjs7QUFFQSxvQkFBSTtBQUNBQSw2QkFBU0gsS0FBS0ksS0FBTCxDQUFXLElBQVgsRUFBaUJSLElBQWpCLENBQVQ7QUFDSCxpQkFGRCxDQUVFLE9BQU9TLENBQVAsRUFBVTtBQUNSYix3QkFBSWMsS0FBSixDQUFVRCxFQUFFRSxLQUFaO0FBQ0EsMkJBQU9MLFNBQVA7QUFDSDs7QUFFRDs7OztBQUlBLG9CQUFJQyxVQUFVLE9BQU9BLE9BQU9LLElBQWQsS0FBdUIsVUFBckMsRUFBaUQ7QUFDN0MsMkJBQU9MLE9BQU9LLElBQVAsQ0FBWU4sT0FBWixFQUFxQixVQUFDRyxDQUFELEVBQU87QUFDL0JiLDRCQUFJYyxLQUFKLENBQVVELEVBQUVFLEtBQVo7QUFDQUw7QUFDSCxxQkFITSxDQUFQO0FBSUg7O0FBRURBLHdCQUFRQyxNQUFSO0FBQ0gsYUF0QjJCLENBQVY7QUFBQSxTQUFWLENBQVI7O0FBd0JBLGVBQU9GLFFBQVFRLEdBQVIsQ0FBWWQsS0FBWixDQUFQO0FBQ0gsS0F4Q1U7O0FBQUEsYUFBc0NlLHdCQUF0QztBQUFBO0FBQUE7O0FBQUEsV0FBc0NBLHdCQUF0QztBQUFBLElBQUo7O0FBMENBLElBQUlDLHdEQUF3QmxCLElBQTVCO0FBQ0EsSUFBSW1CLG9EQUFzQixDQUFDQyxFQUFELEVBQUtDLElBQUwsS0FBYztBQUMzQyxXQUFPLFVBQVUsR0FBR2xCLElBQWIsRUFBbUI7QUFDdEIsY0FBTU8sU0FBU1UsR0FBR1QsS0FBSCxDQUFTLElBQVQsRUFBZVIsSUFBZixDQUFmOztBQUVBLFlBQUksT0FBT2tCLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDNUIsbUJBQU9BLEtBQUtYLE1BQUwsQ0FBUDtBQUNIOztBQUVELGVBQU9BLE1BQVA7QUFDSCxLQVJEO0FBU0gsQ0FWTTtBQVdBLElBQUlZLG9DQUFjLENBQUNDLENBQUQsRUFBSUMsTUFBSixLQUFlQSxNQUFqQztBQUNBLElBQUlDLGtEQUFxQixLQUF6Qjs7QUFFUDs7O0FBR0EsSUFBSTtBQUNBO0FBQ0EsVUFBTUMsV0FBV0MsUUFBUSxXQUFSLENBQWpCO0FBQ0E1QixRQUFJNkIsS0FBSixDQUFVLDRDQUFWOztBQUVBLFlBVk9ILGtCQVVQLHdCQUFxQixJQUFyQjtBQUNBLFlBdkJPTixtQkF1QlAseUJBQXNCTyxTQUFTUCxtQkFBL0I7QUFDQSxZQXpCT0QscUJBeUJQLDJCQUF3QlEsU0FBU1IscUJBQWpDO0FBQ0EsWUFkT0ksV0FjUCxpQkFBY0ksU0FBU0osV0FBdkI7QUFDQSxZQXJFT3JCLG9CQXFFUCwwQkFBdUJ5QixTQUFTekIsb0JBQWhDO0FBQ0gsQ0FWRCxDQVVFLE9BQU9XLENBQVAsRUFBVTtBQUNSYixRQUFJNkIsS0FBSixDQUFVLGlEQUFWO0FBQ0giLCJmaWxlIjoic2hpbS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2dnZXIgZnJvbSAnd2Rpby1sb2dnZXInXG5cbmNvbnN0IGxvZyA9IGxvZ2dlcignd2Rpby1jb25maWcnKVxuY29uc3QgTk9PUCA9ICgpID0+IHt9XG5cbmV4cG9ydCBsZXQgZXhlY3V0ZUhvb2tzV2l0aEFyZ3MgPSBhc3luYyBmdW5jdGlvbiBleGVjdXRlSG9va3NXaXRoQXJnc1NoaW0gKGhvb2tzLCBhcmdzKSB7XG4gICAgLyoqXG4gICAgICogbWFrZSBzdXJlIGhvb2tzIGFyZSBhbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICAgIGhvb2tzID0gW2hvb2tzXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2Ugc3VyZSBhcmdzIGlzIGFuIGFycmF5IHNpbmNlIHdlIGFyZSBjYWxsaW5nIGFwcGx5XG4gICAgICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIGFyZ3MgPSBbYXJnc11cbiAgICB9XG5cbiAgICBob29rcyA9IGhvb2tzLm1hcCgoaG9vaykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBob29rLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlLnN0YWNrKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBhIGNhdGNoIGhhbmRsZXJcbiAgICAgICAgICogc28gaW4gY2FzZSBvZiBhIHJlamVjdGlvbiBpdCB3b24ndCBjYXVzZSB0aGUgaG9vayB0byBmYWlsXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKHJlc29sdmUsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGUuc3RhY2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgfSkpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaG9va3MpXG59XG5cbmV4cG9ydCBsZXQgcnVuVGVzdEluRmliZXJDb250ZXh0ID0gTk9PUFxuZXhwb3J0IGxldCBydW5GbkluRmliZXJDb250ZXh0ID0gKGZuLCBkb25lKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShyZXN1bHQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxufVxuZXhwb3J0IGxldCB3cmFwQ29tbWFuZCA9IChfLCBvcmlnRm4pID0+IG9yaWdGblxuZXhwb3J0IGxldCBoYXNXZGlvU3luY1N1cHBvcnQgPSBmYWxzZVxuXG4vKipcbiAqIHNoaW0gdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSB3cmFwIGNvbW1hbmRzIGlmIHdkaW8tc3luYyBpcyBpbnN0YWxsZWQgYXMgZGVwZW5kZW5jeVxuICovXG50cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuICAgIGNvbnN0IHdkaW9TeW5jID0gcmVxdWlyZSgnd2Rpby1zeW5jJylcbiAgICBsb2cuZGVidWcoJ3dkaW8tc3luYyBmb3VuZCwgcnVubmluZyB0ZXN0cyBzeW5jaHJvbm91cycpXG5cbiAgICBoYXNXZGlvU3luY1N1cHBvcnQgPSB0cnVlXG4gICAgcnVuRm5JbkZpYmVyQ29udGV4dCA9IHdkaW9TeW5jLnJ1bkZuSW5GaWJlckNvbnRleHRcbiAgICBydW5UZXN0SW5GaWJlckNvbnRleHQgPSB3ZGlvU3luYy5ydW5UZXN0SW5GaWJlckNvbnRleHRcbiAgICB3cmFwQ29tbWFuZCA9IHdkaW9TeW5jLndyYXBDb21tYW5kXG4gICAgZXhlY3V0ZUhvb2tzV2l0aEFyZ3MgPSB3ZGlvU3luYy5leGVjdXRlSG9va3NXaXRoQXJnc1xufSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1Zygnd2Rpby1zeW5jIG5vdCBmb3VuZCwgcnVubmluZyB0ZXN0cyBhc3luY2hyb25vdXMnKVxufVxuIl19