'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sourceMapSupport2 = require('source-map-support');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _deepmerge = require('deepmerge');

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _wdioLogger = require('wdio-logger');

var _wdioLogger2 = _interopRequireDefault(_wdioLogger);

var _utils = require('../utils');

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sourceMapSupport2.install)();


const log = (0, _wdioLogger2.default)('wdio-config:ConfigParser');
const MERGE_OPTIONS = { clone: false };

class ConfigParser {
    constructor() {
        this._config = _constants.DEFAULT_CONFIGS;
        this._capabilities = [];
    }

    /**
     * merges config file with default values
     * @param {String} filename path of file relative to current directory
     */
    addConfigFile(filename) {
        if (typeof filename !== 'string') {
            throw new Error('addConfigFile requires filepath');
        }

        var filePath = _path2.default.resolve(process.cwd(), filename);

        try {
            /**
             * clone the original config
             */
            var fileConfig = (0, _deepmerge2.default)(require(filePath).config, {}, MERGE_OPTIONS);

            /**
             * merge capabilities
             */
            const defaultTo = Array.isArray(this._capabilities) ? [] : {};
            this._capabilities = (0, _deepmerge2.default)(this._capabilities, fileConfig.capabilities || defaultTo, MERGE_OPTIONS);
            delete fileConfig.capabilities;

            /**
             * add service hooks and remove them from config
             */
            this.addService(fileConfig);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = _constants.SUPPORTED_HOOKS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    let hookName = _step.value;

                    delete fileConfig[hookName];
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this._config = (0, _deepmerge2.default)(this._config, fileConfig, MERGE_OPTIONS);

            /**
             * detect Selenium backend
             */
            this._config = (0, _deepmerge2.default)((0, _utils.detectBackend)(this._config), this._config, MERGE_OPTIONS);
        } catch (e) {
            log.error(`Failed loading configuration file: ${filePath}`);
            throw e;
        }
    }

    /**
     * merge external object with config object
     * @param  {Object} object  desired object to merge into the config object
     */
    merge(object = {}) {
        this._config = (0, _deepmerge2.default)(this._config, object, MERGE_OPTIONS);
        let spec = Array.isArray(object.spec) ? object.spec : [];
        let exclude = Array.isArray(object.exclude) ? object.exclude : [];

        /**
         * overwrite config specs that got piped into the wdio command
         */
        if (object.specs && object.specs.length > 0) {
            this._config.specs = object.specs;
        } else if (object.exclude && object.exclude.length > 0) {
            this._config.exclude = object.exclude;
        }

        /**
         * merge capabilities
         */
        const defaultTo = Array.isArray(this._capabilities) ? [] : {};
        this._capabilities = (0, _deepmerge2.default)(this._capabilities, this._config.capabilities || defaultTo, MERGE_OPTIONS);

        /**
         * run single spec file only, regardless of multiple-spec specification
         */
        if (spec.length > 0) {
            this._config.specs = [...this.setFilePathToFilterOptions(spec, this._config.specs)];
        }

        if (exclude.length > 0) {
            this._config.exclude = [...this.setFilePathToFilterOptions(exclude, this._config.exclude)];
        }

        /**
         * user and key could get added via cli arguments so we need to detect again
         * Note: cli arguments are on the right and overwrite config
         * if host and port are default, remove them to get new values
         */
        let defaultBackend = (0, _utils.detectBackend)({});
        if (this._config.hostname === defaultBackend.hostname && this._config.port === defaultBackend.port) {
            delete this._config.hostname;
            delete this._config.port;
        }

        this._config = (0, _deepmerge2.default)((0, _utils.detectBackend)(this._config), this._config, MERGE_OPTIONS);
    }

    /**
     * add hooks from services to runner config
     * @param {Object} service  a service is basically an object that contains hook methods
     */
    addService(service) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = _constants.SUPPORTED_HOOKS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                let hookName = _step2.value;

                if (!service[hookName]) {
                    continue;
                }

                if (typeof service[hookName] === 'function') {
                    this._config[hookName].push(service[hookName].bind(service));
                } else if (Array.isArray(service[hookName])) {
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = service[hookName][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            let hook = _step3.value;

                            if (typeof hook === 'function') {
                                this._config[hookName].push(hook.bind(service));
                            }
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    }

    /**
     * get excluded files from config pattern
     */
    getSpecs(capSpecs, capExclude) {
        let specs = ConfigParser.getFilePaths(this._config.specs);
        let spec = Array.isArray(this._config.spec) ? this._config.spec : [];
        let exclude = ConfigParser.getFilePaths(this._config.exclude);
        let suites = Array.isArray(this._config.suite) ? this._config.suite : [];

        /**
         * check if user has specified a specific suites to run
         */
        if (suites.length > 0) {
            let suiteSpecs = [];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = suites[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    let suiteName = _step4.value;

                    // ToDo: log warning if suite was not found
                    let suite = this._config.suites[suiteName];
                    if (suite && Array.isArray(suite)) {
                        suiteSpecs = suiteSpecs.concat(ConfigParser.getFilePaths(suite));
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            if (suiteSpecs.length === 0) {
                throw new Error(`The suite(s) "${suites.join('", "')}" you specified don't exist ` + 'in your config file or doesn\'t contain any files!');
            }

            // Allow --suite and --spec to both be defined on the command line
            // Removing any duplicate tests that could be included
            const tmp_specs = spec.length > 0 ? [...specs, ...suiteSpecs] : suiteSpecs;

            return [...new Set(tmp_specs)];
        }

        if (Array.isArray(capSpecs)) {
            specs = specs.concat(ConfigParser.getFilePaths(capSpecs));
        }

        if (Array.isArray(capExclude)) {
            exclude = exclude.concat(ConfigParser.getFilePaths(capExclude));
        }

        return specs.filter(spec => exclude.indexOf(spec) < 0);
    }

    /**
     * sets config attribute with file paths from filtering
     * options from cli argument
     *
     * @param  {String} cliArgFileList  list of files in a string from
     * @param  {Object} config  config object that stores the spec and exlcude attributes
     * cli argument
     * @return {String[]} List of files that should be included or excluded
     */
    setFilePathToFilterOptions(cliArgFileList, config) {
        const filesToFilter = new Set();
        const fileList = ConfigParser.getFilePaths(config);
        cliArgFileList.forEach(filtered_file => {
            if (_fs2.default.existsSync(filtered_file) && _fs2.default.lstatSync(filtered_file).isFile()) {
                filesToFilter.add(_path2.default.resolve(process.cwd(), filtered_file));
            } else {
                fileList.forEach(file => {
                    if (file.match(filtered_file)) {
                        filesToFilter.add(file);
                    }
                });
            }
        });
        if (filesToFilter.size === 0) {
            throw new Error(`spec file(s) ${cliArgFileList.join(`, `)} not found`);
        }

        return filesToFilter;
    }

    /**
     * return configs
     */
    getConfig() {
        return this._config;
    }

    /**
     * return capabilities
     */
    getCapabilities(i) {
        if (typeof i === 'number' && this._capabilities[i]) {
            return this._capabilities[i];
        }

        return this._capabilities;
    }

    /**
     * returns a flatten list of globed files
     *
     * @param  {String[]} filenames  list of files to glob
     * @return {String[]} list of files
     */
    static getFilePaths(patterns, omitWarnings) {
        let files = [];

        if (typeof patterns === 'string') {
            patterns = [patterns];
        }

        if (!Array.isArray(patterns)) {
            throw new Error('specs or exclude property should be an array of strings');
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = patterns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                let pattern = _step5.value;

                let filenames = _glob2.default.sync(pattern);

                filenames = filenames.filter(filename => filename.slice(-3) === '.js' || filename.slice(-3) === '.ts' || filename.slice(-8) === '.feature' || filename.slice(-7) === '.coffee');

                filenames = filenames.map(filename => _path2.default.isAbsolute(filename) ? _path2.default.normalize(filename) : _path2.default.resolve(process.cwd(), filename));

                if (filenames.length === 0 && !omitWarnings) {
                    log.warn('pattern', pattern, 'did not match any file');
                }

                files = (0, _deepmerge2.default)(files, filenames, MERGE_OPTIONS);
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        return files;
    }
}
exports.default = ConfigParser;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvQ29uZmlnUGFyc2VyLmpzIl0sIm5hbWVzIjpbImxvZyIsIk1FUkdFX09QVElPTlMiLCJjbG9uZSIsIkNvbmZpZ1BhcnNlciIsImNvbnN0cnVjdG9yIiwiX2NvbmZpZyIsIkRFRkFVTFRfQ09ORklHUyIsIl9jYXBhYmlsaXRpZXMiLCJhZGRDb25maWdGaWxlIiwiZmlsZW5hbWUiLCJFcnJvciIsImZpbGVQYXRoIiwicGF0aCIsInJlc29sdmUiLCJwcm9jZXNzIiwiY3dkIiwiZmlsZUNvbmZpZyIsInJlcXVpcmUiLCJjb25maWciLCJkZWZhdWx0VG8iLCJBcnJheSIsImlzQXJyYXkiLCJjYXBhYmlsaXRpZXMiLCJhZGRTZXJ2aWNlIiwiU1VQUE9SVEVEX0hPT0tTIiwiaG9va05hbWUiLCJlIiwiZXJyb3IiLCJtZXJnZSIsIm9iamVjdCIsInNwZWMiLCJleGNsdWRlIiwic3BlY3MiLCJsZW5ndGgiLCJzZXRGaWxlUGF0aFRvRmlsdGVyT3B0aW9ucyIsImRlZmF1bHRCYWNrZW5kIiwiaG9zdG5hbWUiLCJwb3J0Iiwic2VydmljZSIsInB1c2giLCJiaW5kIiwiaG9vayIsImdldFNwZWNzIiwiY2FwU3BlY3MiLCJjYXBFeGNsdWRlIiwiZ2V0RmlsZVBhdGhzIiwic3VpdGVzIiwic3VpdGUiLCJzdWl0ZVNwZWNzIiwic3VpdGVOYW1lIiwiY29uY2F0Iiwiam9pbiIsInRtcF9zcGVjcyIsIlNldCIsImZpbHRlciIsImluZGV4T2YiLCJjbGlBcmdGaWxlTGlzdCIsImZpbGVzVG9GaWx0ZXIiLCJmaWxlTGlzdCIsImZvckVhY2giLCJmaWx0ZXJlZF9maWxlIiwiZnMiLCJleGlzdHNTeW5jIiwibHN0YXRTeW5jIiwiaXNGaWxlIiwiYWRkIiwiZmlsZSIsIm1hdGNoIiwic2l6ZSIsImdldENvbmZpZyIsImdldENhcGFiaWxpdGllcyIsImkiLCJwYXR0ZXJucyIsIm9taXRXYXJuaW5ncyIsImZpbGVzIiwicGF0dGVybiIsImZpbGVuYW1lcyIsImds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LFVBQUwsQ0FBZ0J4RSxRQUFoQixJQUE0QkcsZUFBS3NFLFNBQUwsQ0FBZXpFLFFBQWYsQ0FBNUIsR0FBdURHLGVBQUtDLE9BQUwsQ0FBYUMsUUFBUUMsR0FBUixFQUFiLEVBQTRCTixRQUE1QixDQUQvQyxDQUFaOztBQUdBLG9CQUFJbUUsVUFBVTNDLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEIsQ0FBQ3dDLFlBQS9CLEVBQTZDO0FBQ3pDekUsd0JBQUltRixJQUFKLENBQVMsU0FBVCxFQUFvQlIsT0FBcEIsRUFBNkIsd0JBQTdCO0FBQ0g7O0FBRURELHdCQUFRLHlCQUFNQSxLQUFOLEVBQWFFLFNBQWIsRUFBd0IzRSxhQUF4QixDQUFSO0FBQ0g7QUE1QndDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBOEJ6QyxlQUFPeUUsS0FBUDtBQUNIO0FBN1A2QjtrQkFBYnZFLFkiLCJmaWxlIjoiQ29uZmlnUGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InXG5pbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ3dkaW8tbG9nZ2VyJ1xuXG5pbXBvcnQgeyBkZXRlY3RCYWNrZW5kIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmltcG9ydCB7IERFRkFVTFRfQ09ORklHUywgU1VQUE9SVEVEX0hPT0tTIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuXG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dkaW8tY29uZmlnOkNvbmZpZ1BhcnNlcicpXG5jb25zdCBNRVJHRV9PUFRJT05TID0geyBjbG9uZTogZmFsc2UgfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWdQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdTXG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IFtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWVyZ2VzIGNvbmZpZyBmaWxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgcGF0aCBvZiBmaWxlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG4gICAgICovXG4gICAgYWRkQ29uZmlnRmlsZSAoZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkQ29uZmlnRmlsZSByZXF1aXJlcyBmaWxlcGF0aCcpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgZmlsZW5hbWUpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY2xvbmUgdGhlIG9yaWdpbmFsIGNvbmZpZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZmlsZUNvbmZpZyA9IG1lcmdlKHJlcXVpcmUoZmlsZVBhdGgpLmNvbmZpZywge30sIE1FUkdFX09QVElPTlMpXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbWVyZ2UgY2FwYWJpbGl0aWVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUbyA9IEFycmF5LmlzQXJyYXkodGhpcy5fY2FwYWJpbGl0aWVzKSA/IFtdIDoge31cbiAgICAgICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IG1lcmdlKHRoaXMuX2NhcGFiaWxpdGllcywgZmlsZUNvbmZpZy5jYXBhYmlsaXRpZXMgfHwgZGVmYXVsdFRvLCBNRVJHRV9PUFRJT05TKVxuICAgICAgICAgICAgZGVsZXRlIGZpbGVDb25maWcuY2FwYWJpbGl0aWVzXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYWRkIHNlcnZpY2UgaG9va3MgYW5kIHJlbW92ZSB0aGVtIGZyb20gY29uZmlnXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYWRkU2VydmljZShmaWxlQ29uZmlnKVxuICAgICAgICAgICAgZm9yIChsZXQgaG9va05hbWUgb2YgU1VQUE9SVEVEX0hPT0tTKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZpbGVDb25maWdbaG9va05hbWVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IG1lcmdlKHRoaXMuX2NvbmZpZywgZmlsZUNvbmZpZywgTUVSR0VfT1BUSU9OUylcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBkZXRlY3QgU2VsZW5pdW0gYmFja2VuZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBtZXJnZShkZXRlY3RCYWNrZW5kKHRoaXMuX2NvbmZpZyksIHRoaXMuX2NvbmZpZywgTUVSR0VfT1BUSU9OUylcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBGYWlsZWQgbG9hZGluZyBjb25maWd1cmF0aW9uIGZpbGU6ICR7ZmlsZVBhdGh9YClcbiAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1lcmdlIGV4dGVybmFsIG9iamVjdCB3aXRoIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdCAgZGVzaXJlZCBvYmplY3QgdG8gbWVyZ2UgaW50byB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqL1xuICAgIG1lcmdlIChvYmplY3QgPSB7fSkge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBtZXJnZSh0aGlzLl9jb25maWcsIG9iamVjdCwgTUVSR0VfT1BUSU9OUylcbiAgICAgICAgbGV0IHNwZWMgPSBBcnJheS5pc0FycmF5KG9iamVjdC5zcGVjKSA/IG9iamVjdC5zcGVjIDogW11cbiAgICAgICAgbGV0IGV4Y2x1ZGUgPSBBcnJheS5pc0FycmF5KG9iamVjdC5leGNsdWRlKSA/IG9iamVjdC5leGNsdWRlIDogW11cblxuICAgICAgICAvKipcbiAgICAgICAgICogb3ZlcndyaXRlIGNvbmZpZyBzcGVjcyB0aGF0IGdvdCBwaXBlZCBpbnRvIHRoZSB3ZGlvIGNvbW1hbmRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvYmplY3Quc3BlY3MgJiYgb2JqZWN0LnNwZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5zcGVjcyA9IG9iamVjdC5zcGVjc1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5leGNsdWRlICYmIG9iamVjdC5leGNsdWRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5leGNsdWRlID0gb2JqZWN0LmV4Y2x1ZGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXJnZSBjYXBhYmlsaXRpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlZmF1bHRUbyA9IEFycmF5LmlzQXJyYXkodGhpcy5fY2FwYWJpbGl0aWVzKSA/IFtdIDoge31cbiAgICAgICAgdGhpcy5fY2FwYWJpbGl0aWVzID0gbWVyZ2UodGhpcy5fY2FwYWJpbGl0aWVzLCB0aGlzLl9jb25maWcuY2FwYWJpbGl0aWVzIHx8IGRlZmF1bHRUbywgTUVSR0VfT1BUSU9OUylcblxuICAgICAgICAvKipcbiAgICAgICAgICogcnVuIHNpbmdsZSBzcGVjIGZpbGUgb25seSwgcmVnYXJkbGVzcyBvZiBtdWx0aXBsZS1zcGVjIHNwZWNpZmljYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChzcGVjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5zcGVjcyA9IFsuLi50aGlzLnNldEZpbGVQYXRoVG9GaWx0ZXJPcHRpb25zKHNwZWMsIHRoaXMuX2NvbmZpZy5zcGVjcyldXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChleGNsdWRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5leGNsdWRlID0gWy4uLnRoaXMuc2V0RmlsZVBhdGhUb0ZpbHRlck9wdGlvbnMoZXhjbHVkZSwgdGhpcy5fY29uZmlnLmV4Y2x1ZGUpXVxuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VyIGFuZCBrZXkgY291bGQgZ2V0IGFkZGVkIHZpYSBjbGkgYXJndW1lbnRzIHNvIHdlIG5lZWQgdG8gZGV0ZWN0IGFnYWluXG4gICAgICAgICAqIE5vdGU6IGNsaSBhcmd1bWVudHMgYXJlIG9uIHRoZSByaWdodCBhbmQgb3ZlcndyaXRlIGNvbmZpZ1xuICAgICAgICAgKiBpZiBob3N0IGFuZCBwb3J0IGFyZSBkZWZhdWx0LCByZW1vdmUgdGhlbSB0byBnZXQgbmV3IHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGRlZmF1bHRCYWNrZW5kID0gZGV0ZWN0QmFja2VuZCh7fSlcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ob3N0bmFtZSA9PT0gZGVmYXVsdEJhY2tlbmQuaG9zdG5hbWUgJiYgdGhpcy5fY29uZmlnLnBvcnQgPT09IGRlZmF1bHRCYWNrZW5kLnBvcnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb25maWcuaG9zdG5hbWVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb25maWcucG9ydFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29uZmlnID0gbWVyZ2UoZGV0ZWN0QmFja2VuZCh0aGlzLl9jb25maWcpLCB0aGlzLl9jb25maWcsIE1FUkdFX09QVElPTlMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGhvb2tzIGZyb20gc2VydmljZXMgdG8gcnVubmVyIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlICBhIHNlcnZpY2UgaXMgYmFzaWNhbGx5IGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGhvb2sgbWV0aG9kc1xuICAgICAqL1xuICAgIGFkZFNlcnZpY2UgKHNlcnZpY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaG9va05hbWUgb2YgU1VQUE9SVEVEX0hPT0tTKSB7XG4gICAgICAgICAgICBpZiAoIXNlcnZpY2VbaG9va05hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2aWNlW2hvb2tOYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbmZpZ1tob29rTmFtZV0ucHVzaChzZXJ2aWNlW2hvb2tOYW1lXS5iaW5kKHNlcnZpY2UpKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcnZpY2VbaG9va05hbWVdKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhvb2sgb2Ygc2VydmljZVtob29rTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25maWdbaG9va05hbWVdLnB1c2goaG9vay5iaW5kKHNlcnZpY2UpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGV4Y2x1ZGVkIGZpbGVzIGZyb20gY29uZmlnIHBhdHRlcm5cbiAgICAgKi9cbiAgICBnZXRTcGVjcyAoY2FwU3BlY3MsIGNhcEV4Y2x1ZGUpIHtcbiAgICAgICAgbGV0IHNwZWNzID0gQ29uZmlnUGFyc2VyLmdldEZpbGVQYXRocyh0aGlzLl9jb25maWcuc3BlY3MpXG4gICAgICAgIGxldCBzcGVjICA9IEFycmF5LmlzQXJyYXkodGhpcy5fY29uZmlnLnNwZWMpID8gdGhpcy5fY29uZmlnLnNwZWMgOiBbXVxuICAgICAgICBsZXQgZXhjbHVkZSA9IENvbmZpZ1BhcnNlci5nZXRGaWxlUGF0aHModGhpcy5fY29uZmlnLmV4Y2x1ZGUpXG4gICAgICAgIGxldCBzdWl0ZXMgPSBBcnJheS5pc0FycmF5KHRoaXMuX2NvbmZpZy5zdWl0ZSkgPyB0aGlzLl9jb25maWcuc3VpdGUgOiBbXVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiB1c2VyIGhhcyBzcGVjaWZpZWQgYSBzcGVjaWZpYyBzdWl0ZXMgdG8gcnVuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc3VpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzdWl0ZVNwZWNzID0gW11cbiAgICAgICAgICAgIGZvciAobGV0IHN1aXRlTmFtZSBvZiBzdWl0ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBUb0RvOiBsb2cgd2FybmluZyBpZiBzdWl0ZSB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgbGV0IHN1aXRlID0gdGhpcy5fY29uZmlnLnN1aXRlc1tzdWl0ZU5hbWVdXG4gICAgICAgICAgICAgICAgaWYgKHN1aXRlICYmIEFycmF5LmlzQXJyYXkoc3VpdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1aXRlU3BlY3MgPSBzdWl0ZVNwZWNzLmNvbmNhdChDb25maWdQYXJzZXIuZ2V0RmlsZVBhdGhzKHN1aXRlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdWl0ZVNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN1aXRlKHMpIFwiJHtzdWl0ZXMuam9pbignXCIsIFwiJyl9XCIgeW91IHNwZWNpZmllZCBkb24ndCBleGlzdCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luIHlvdXIgY29uZmlnIGZpbGUgb3IgZG9lc25cXCd0IGNvbnRhaW4gYW55IGZpbGVzIScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IC0tc3VpdGUgYW5kIC0tc3BlYyB0byBib3RoIGJlIGRlZmluZWQgb24gdGhlIGNvbW1hbmQgbGluZVxuICAgICAgICAgICAgLy8gUmVtb3ZpbmcgYW55IGR1cGxpY2F0ZSB0ZXN0cyB0aGF0IGNvdWxkIGJlIGluY2x1ZGVkXG4gICAgICAgICAgICBjb25zdCB0bXBfc3BlY3MgPSBzcGVjLmxlbmd0aCA+IDAgPyBbLi4uc3BlY3MsIC4uLnN1aXRlU3BlY3NdIDogc3VpdGVTcGVjc1xuXG4gICAgICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQodG1wX3NwZWNzKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhcFNwZWNzKSkge1xuICAgICAgICAgICAgc3BlY3MgPSBzcGVjcy5jb25jYXQoQ29uZmlnUGFyc2VyLmdldEZpbGVQYXRocyhjYXBTcGVjcykpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXBFeGNsdWRlKSkge1xuICAgICAgICAgICAgZXhjbHVkZSA9IGV4Y2x1ZGUuY29uY2F0KENvbmZpZ1BhcnNlci5nZXRGaWxlUGF0aHMoY2FwRXhjbHVkZSkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3BlY3MuZmlsdGVyKHNwZWMgPT4gZXhjbHVkZS5pbmRleE9mKHNwZWMpIDwgMClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIGNvbmZpZyBhdHRyaWJ1dGUgd2l0aCBmaWxlIHBhdGhzIGZyb20gZmlsdGVyaW5nXG4gICAgICogb3B0aW9ucyBmcm9tIGNsaSBhcmd1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjbGlBcmdGaWxlTGlzdCAgbGlzdCBvZiBmaWxlcyBpbiBhIHN0cmluZyBmcm9tXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjb25maWcgIGNvbmZpZyBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIHNwZWMgYW5kIGV4bGN1ZGUgYXR0cmlidXRlc1xuICAgICAqIGNsaSBhcmd1bWVudFxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSBMaXN0IG9mIGZpbGVzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIG9yIGV4Y2x1ZGVkXG4gICAgICovXG4gICAgc2V0RmlsZVBhdGhUb0ZpbHRlck9wdGlvbnMgKGNsaUFyZ0ZpbGVMaXN0LCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgZmlsZXNUb0ZpbHRlciA9IG5ldyBTZXQoKVxuICAgICAgICBjb25zdCBmaWxlTGlzdCA9IENvbmZpZ1BhcnNlci5nZXRGaWxlUGF0aHMoY29uZmlnKVxuICAgICAgICBjbGlBcmdGaWxlTGlzdC5mb3JFYWNoKGZpbHRlcmVkX2ZpbGUgPT4ge1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsdGVyZWRfZmlsZSkgJiYgZnMubHN0YXRTeW5jKGZpbHRlcmVkX2ZpbGUpLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgZmlsZXNUb0ZpbHRlci5hZGQocGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIGZpbHRlcmVkX2ZpbGUpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZUxpc3QuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUubWF0Y2goZmlsdGVyZWRfZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzVG9GaWx0ZXIuYWRkKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBpZiAoZmlsZXNUb0ZpbHRlci5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNwZWMgZmlsZShzKSAke2NsaUFyZ0ZpbGVMaXN0LmpvaW4oYCwgYCl9IG5vdCBmb3VuZGApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmaWxlc1RvRmlsdGVyXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvbmZpZ3NcbiAgICAgKi9cbiAgICBnZXRDb25maWcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNhcGFiaWxpdGllc1xuICAgICAqL1xuICAgIGdldENhcGFiaWxpdGllcyAoaSkge1xuICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdudW1iZXInICYmIHRoaXMuX2NhcGFiaWxpdGllc1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdGllc1tpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdGllc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBmbGF0dGVuIGxpc3Qgb2YgZ2xvYmVkIGZpbGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gZmlsZW5hbWVzICBsaXN0IG9mIGZpbGVzIHRvIGdsb2JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gbGlzdCBvZiBmaWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGaWxlUGF0aHMgKHBhdHRlcm5zLCBvbWl0V2FybmluZ3MpIHtcbiAgICAgICAgbGV0IGZpbGVzID0gW11cblxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm5zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybnMgPSBbcGF0dGVybnNdXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0dGVybnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWNzIG9yIGV4Y2x1ZGUgcHJvcGVydHkgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MnKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAgbGV0IGZpbGVuYW1lcyA9IGdsb2Iuc3luYyhwYXR0ZXJuKVxuXG4gICAgICAgICAgICBmaWxlbmFtZXMgPSBmaWxlbmFtZXMuZmlsdGVyKGZpbGVuYW1lID0+XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUuc2xpY2UoLTMpID09PSAnLmpzJyB8fFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLnNsaWNlKC0zKSA9PT0gJy50cycgfHxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZS5zbGljZSgtOCkgPT09ICcuZmVhdHVyZScgfHxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZS5zbGljZSgtNykgPT09ICcuY29mZmVlJylcblxuICAgICAgICAgICAgZmlsZW5hbWVzID0gZmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PlxuICAgICAgICAgICAgICAgIHBhdGguaXNBYnNvbHV0ZShmaWxlbmFtZSkgPyBwYXRoLm5vcm1hbGl6ZShmaWxlbmFtZSkgOiBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgZmlsZW5hbWUpKVxuXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWVzLmxlbmd0aCA9PT0gMCAmJiAhb21pdFdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oJ3BhdHRlcm4nLCBwYXR0ZXJuLCAnZGlkIG5vdCBtYXRjaCBhbnkgZmlsZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbGVzID0gbWVyZ2UoZmlsZXMsIGZpbGVuYW1lcywgTUVSR0VfT1BUSU9OUylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWxlc1xuICAgIH1cbn1cbiJdfQ==