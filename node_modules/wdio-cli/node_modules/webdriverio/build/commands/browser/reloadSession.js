"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reloadSession;

require("source-map-support/register");

var _request = _interopRequireDefault(require("webdriver/build/request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * Creates a new Selenium session with your current capabilities. This is useful if you
 * test highly stateful application where you need to clean the browser session between
 * the tests in your spec file to avoid creating hundreds of single test files with WDIO.
 * Be careful though, this command affects your test time tremendously since spawning
 * new Selenium sessions is very time consuming especially when using cloud services.
 *
 * <example>
    :reloadSync.js
    it('should reload my session', () => {
        console.log(browser.sessionId) // outputs: e042b3f3cd5a479da4e171825e96e655
        browser.reload()
        console.log(browser.sessionId) // outputs: 9a0d9bf9d4864160aa982c50cf18a573
    })
 * </example>
 *
 * @alias browser.reload
 * @type utility
 *
 */
async function reloadSession() {
  const oldSessionId = this.sessionId;
  /**
   * end current running session
   */

  await this.deleteSession();
  const sessionRequest = new _request.default('POST', '/session', {
    capabilities: this.options.requestedCapabilities,
    // W3C compliant
    desiredCapabilities: this.options.requestedCapabilities // JSONWP compliant

  });
  const response = await sessionRequest.makeRequest(this.options);
  const newSessionId = response.sessionId;
  this.sessionId = newSessionId;

  if (Array.isArray(this.options.onReload) && this.options.onReload.length) {
    await Promise.all(this.options.onReload.map(hook => hook(oldSessionId, newSessionId)));
  }

  return newSessionId;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9icm93c2VyL3JlbG9hZFNlc3Npb24uanMiXSwibmFtZXMiOlsicmVsb2FkU2Vzc2lvbiIsIm9sZFNlc3Npb25JZCIsInNlc3Npb25JZCIsImRlbGV0ZVNlc3Npb24iLCJzZXNzaW9uUmVxdWVzdCIsIldlYkRyaXZlclJlcXVlc3QiLCJjYXBhYmlsaXRpZXMiLCJvcHRpb25zIiwicmVxdWVzdGVkQ2FwYWJpbGl0aWVzIiwiZGVzaXJlZENhcGFiaWxpdGllcyIsInJlc3BvbnNlIiwibWFrZVJlcXVlc3QiLCJuZXdTZXNzaW9uSWQiLCJBcnJheSIsImlzQXJyYXkiLCJvblJlbG9hZCIsImxlbmd0aCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJob29rIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFzQkE7Ozs7QUF0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCZSxlQUFlQSxhQUFmLEdBQWdDO0FBQzNDLFFBQU1DLFlBQVksR0FBRyxLQUFLQyxTQUExQjtBQUVBOzs7O0FBR0EsUUFBTSxLQUFLQyxhQUFMLEVBQU47QUFFQSxRQUFNQyxjQUFjLEdBQUcsSUFBSUMsZ0JBQUosQ0FDbkIsTUFEbUIsRUFFbkIsVUFGbUIsRUFHbkI7QUFDSUMsSUFBQUEsWUFBWSxFQUFFLEtBQUtDLE9BQUwsQ0FBYUMscUJBRC9CO0FBQ3NEO0FBQ2xEQyxJQUFBQSxtQkFBbUIsRUFBRSxLQUFLRixPQUFMLENBQWFDLHFCQUZ0QyxDQUU0RDs7QUFGNUQsR0FIbUIsQ0FBdkI7QUFTQSxRQUFNRSxRQUFRLEdBQUcsTUFBTU4sY0FBYyxDQUFDTyxXQUFmLENBQTJCLEtBQUtKLE9BQWhDLENBQXZCO0FBQ0EsUUFBTUssWUFBWSxHQUFHRixRQUFRLENBQUNSLFNBQTlCO0FBQ0EsT0FBS0EsU0FBTCxHQUFpQlUsWUFBakI7O0FBRUEsTUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWMsS0FBS1AsT0FBTCxDQUFhUSxRQUEzQixLQUF3QyxLQUFLUixPQUFMLENBQWFRLFFBQWIsQ0FBc0JDLE1BQWxFLEVBQTBFO0FBQ3RFLFVBQU1DLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUtYLE9BQUwsQ0FBYVEsUUFBYixDQUFzQkksR0FBdEIsQ0FBMkJDLElBQUQsSUFBVUEsSUFBSSxDQUFDbkIsWUFBRCxFQUFlVyxZQUFmLENBQXhDLENBQVosQ0FBTjtBQUNIOztBQUVELFNBQU9BLFlBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIENyZWF0ZXMgYSBuZXcgU2VsZW5pdW0gc2Vzc2lvbiB3aXRoIHlvdXIgY3VycmVudCBjYXBhYmlsaXRpZXMuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdVxuICogdGVzdCBoaWdobHkgc3RhdGVmdWwgYXBwbGljYXRpb24gd2hlcmUgeW91IG5lZWQgdG8gY2xlYW4gdGhlIGJyb3dzZXIgc2Vzc2lvbiBiZXR3ZWVuXG4gKiB0aGUgdGVzdHMgaW4geW91ciBzcGVjIGZpbGUgdG8gYXZvaWQgY3JlYXRpbmcgaHVuZHJlZHMgb2Ygc2luZ2xlIHRlc3QgZmlsZXMgd2l0aCBXRElPLlxuICogQmUgY2FyZWZ1bCB0aG91Z2gsIHRoaXMgY29tbWFuZCBhZmZlY3RzIHlvdXIgdGVzdCB0aW1lIHRyZW1lbmRvdXNseSBzaW5jZSBzcGF3bmluZ1xuICogbmV3IFNlbGVuaXVtIHNlc3Npb25zIGlzIHZlcnkgdGltZSBjb25zdW1pbmcgZXNwZWNpYWxseSB3aGVuIHVzaW5nIGNsb3VkIHNlcnZpY2VzLlxuICpcbiAqIDxleGFtcGxlPlxuICAgIDpyZWxvYWRTeW5jLmpzXG4gICAgaXQoJ3Nob3VsZCByZWxvYWQgbXkgc2Vzc2lvbicsICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYnJvd3Nlci5zZXNzaW9uSWQpIC8vIG91dHB1dHM6IGUwNDJiM2YzY2Q1YTQ3OWRhNGUxNzE4MjVlOTZlNjU1XG4gICAgICAgIGJyb3dzZXIucmVsb2FkKClcbiAgICAgICAgY29uc29sZS5sb2coYnJvd3Nlci5zZXNzaW9uSWQpIC8vIG91dHB1dHM6IDlhMGQ5YmY5ZDQ4NjQxNjBhYTk4MmM1MGNmMThhNTczXG4gICAgfSlcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKiBAYWxpYXMgYnJvd3Nlci5yZWxvYWRcbiAqIEB0eXBlIHV0aWxpdHlcbiAqXG4gKi9cblxuaW1wb3J0IFdlYkRyaXZlclJlcXVlc3QgZnJvbSAnd2ViZHJpdmVyL2J1aWxkL3JlcXVlc3QnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHJlbG9hZFNlc3Npb24gKCkge1xuICAgIGNvbnN0IG9sZFNlc3Npb25JZCA9IHRoaXMuc2Vzc2lvbklkXG5cbiAgICAvKipcbiAgICAgKiBlbmQgY3VycmVudCBydW5uaW5nIHNlc3Npb25cbiAgICAgKi9cbiAgICBhd2FpdCB0aGlzLmRlbGV0ZVNlc3Npb24oKVxuXG4gICAgY29uc3Qgc2Vzc2lvblJlcXVlc3QgPSBuZXcgV2ViRHJpdmVyUmVxdWVzdChcbiAgICAgICAgJ1BPU1QnLFxuICAgICAgICAnL3Nlc3Npb24nLFxuICAgICAgICB7XG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRDYXBhYmlsaXRpZXMsIC8vIFczQyBjb21wbGlhbnRcbiAgICAgICAgICAgIGRlc2lyZWRDYXBhYmlsaXRpZXM6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRDYXBhYmlsaXRpZXMgLy8gSlNPTldQIGNvbXBsaWFudFxuICAgICAgICB9XG4gICAgKVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXNzaW9uUmVxdWVzdC5tYWtlUmVxdWVzdCh0aGlzLm9wdGlvbnMpXG4gICAgY29uc3QgbmV3U2Vzc2lvbklkID0gcmVzcG9uc2Uuc2Vzc2lvbklkXG4gICAgdGhpcy5zZXNzaW9uSWQgPSBuZXdTZXNzaW9uSWRcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5vblJlbG9hZCkgJiYgdGhpcy5vcHRpb25zLm9uUmVsb2FkLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLm9wdGlvbnMub25SZWxvYWQubWFwKChob29rKSA9PiBob29rKG9sZFNlc3Npb25JZCwgbmV3U2Vzc2lvbklkKSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1Nlc3Npb25JZFxufVxuIl19