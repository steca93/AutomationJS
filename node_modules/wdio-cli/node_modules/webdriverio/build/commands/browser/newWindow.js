"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = newWindow;

require("source-map-support/register");

var _newWindow = _interopRequireDefault(require("../../scripts/newWindow"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * Open new window in browser. This command is the equivalent function to `window.open()`. This command does not
 * work in mobile environments.
 *
 * __Note:__ When calling this command you automatically switch to the new window.
 *
 * <example>
    :newWindowSync.js
    it('should open a new tab', () => {
        browser.url('http://google.com')
        console.log(browser.getTitle()) // outputs: "Google"

        browser.newWindow('http://webdriver.io', 'WebdriverIO window', 'width=420,height=230,resizable,scrollbars=yes,status=1')
        console.log(browser.getTitle()) // outputs: "WebdriverIO - WebDriver bindings for Node.js"

        browser.close()
        console.log(browser.getTitle()) // outputs: "Google"
    });
 * </example>
 *
 * @param {String} url            website URL to open
 * @param {String} windowName     name of the new window
 * @param {String} windowFeatures features of opened window (e.g. size, position, scrollbars, etc.)
 * @return {String}                id of window handle of new tab
 *
 * @uses browser/execute, protocol/getWindowHandles, protocol/switchToWindow
 * @alias browser.newWindow
 * @type window
 */
async function newWindow(url, windowName = 'New Window', windowFeatures = '') {
  /*!
   * parameter check
   */
  if (typeof url !== 'string') {
    throw new Error('number or type of arguments don\'t agree with newWindow command');
  }
  /*!
   * mobile check
   */


  const {
    isMobile
  } = (0, _utils.mobileDetector)(this.capabilities);

  if (isMobile) {
    throw new Error('newWindow command is not supported on mobile platforms');
  }

  await this.execute(_newWindow.default, url, windowName, windowFeatures);
  const tabs = await this.getWindowHandles();
  const newTab = tabs.pop();
  await this.switchToWindow(newTab);
  return newTab;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9icm93c2VyL25ld1dpbmRvdy5qcyJdLCJuYW1lcyI6WyJuZXdXaW5kb3ciLCJ1cmwiLCJ3aW5kb3dOYW1lIiwid2luZG93RmVhdHVyZXMiLCJFcnJvciIsImlzTW9iaWxlIiwiY2FwYWJpbGl0aWVzIiwiZXhlY3V0ZSIsIm5ld1dpbmRvd0hlbHBlciIsInRhYnMiLCJnZXRXaW5kb3dIYW5kbGVzIiwibmV3VGFiIiwicG9wIiwic3dpdGNoVG9XaW5kb3ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWdDQTs7QUFDQTs7OztBQWhDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NlLGVBQWVBLFNBQWYsQ0FBMEJDLEdBQTFCLEVBQStCQyxVQUFVLEdBQUcsWUFBNUMsRUFBMERDLGNBQWMsR0FBRyxFQUEzRSxFQUErRTtBQUMxRjs7O0FBR0EsTUFBSSxPQUFPRixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDekIsVUFBTSxJQUFJRyxLQUFKLENBQVUsaUVBQVYsQ0FBTjtBQUNIO0FBRUQ7Ozs7O0FBR0EsUUFBTTtBQUFFQyxJQUFBQTtBQUFGLE1BQWUsMkJBQWUsS0FBS0MsWUFBcEIsQ0FBckI7O0FBQ0EsTUFBSUQsUUFBSixFQUFjO0FBQ1YsVUFBTSxJQUFJRCxLQUFKLENBQVUsd0RBQVYsQ0FBTjtBQUNIOztBQUVELFFBQU0sS0FBS0csT0FBTCxDQUFhQyxrQkFBYixFQUE4QlAsR0FBOUIsRUFBbUNDLFVBQW5DLEVBQStDQyxjQUEvQyxDQUFOO0FBRUEsUUFBTU0sSUFBSSxHQUFHLE1BQU0sS0FBS0MsZ0JBQUwsRUFBbkI7QUFDQSxRQUFNQyxNQUFNLEdBQUdGLElBQUksQ0FBQ0csR0FBTCxFQUFmO0FBRUEsUUFBTSxLQUFLQyxjQUFMLENBQW9CRixNQUFwQixDQUFOO0FBQ0EsU0FBT0EsTUFBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqXG4gKiBPcGVuIG5ldyB3aW5kb3cgaW4gYnJvd3Nlci4gVGhpcyBjb21tYW5kIGlzIHRoZSBlcXVpdmFsZW50IGZ1bmN0aW9uIHRvIGB3aW5kb3cub3BlbigpYC4gVGhpcyBjb21tYW5kIGRvZXMgbm90XG4gKiB3b3JrIGluIG1vYmlsZSBlbnZpcm9ubWVudHMuXG4gKlxuICogX19Ob3RlOl9fIFdoZW4gY2FsbGluZyB0aGlzIGNvbW1hbmQgeW91IGF1dG9tYXRpY2FsbHkgc3dpdGNoIHRvIHRoZSBuZXcgd2luZG93LlxuICpcbiAqIDxleGFtcGxlPlxuICAgIDpuZXdXaW5kb3dTeW5jLmpzXG4gICAgaXQoJ3Nob3VsZCBvcGVuIGEgbmV3IHRhYicsICgpID0+IHtcbiAgICAgICAgYnJvd3Nlci51cmwoJ2h0dHA6Ly9nb29nbGUuY29tJylcbiAgICAgICAgY29uc29sZS5sb2coYnJvd3Nlci5nZXRUaXRsZSgpKSAvLyBvdXRwdXRzOiBcIkdvb2dsZVwiXG5cbiAgICAgICAgYnJvd3Nlci5uZXdXaW5kb3coJ2h0dHA6Ly93ZWJkcml2ZXIuaW8nLCAnV2ViZHJpdmVySU8gd2luZG93JywgJ3dpZHRoPTQyMCxoZWlnaHQ9MjMwLHJlc2l6YWJsZSxzY3JvbGxiYXJzPXllcyxzdGF0dXM9MScpXG4gICAgICAgIGNvbnNvbGUubG9nKGJyb3dzZXIuZ2V0VGl0bGUoKSkgLy8gb3V0cHV0czogXCJXZWJkcml2ZXJJTyAtIFdlYkRyaXZlciBiaW5kaW5ncyBmb3IgTm9kZS5qc1wiXG5cbiAgICAgICAgYnJvd3Nlci5jbG9zZSgpXG4gICAgICAgIGNvbnNvbGUubG9nKGJyb3dzZXIuZ2V0VGl0bGUoKSkgLy8gb3V0cHV0czogXCJHb29nbGVcIlxuICAgIH0pO1xuICogPC9leGFtcGxlPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgICAgICB3ZWJzaXRlIFVSTCB0byBvcGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gd2luZG93TmFtZSAgICAgbmFtZSBvZiB0aGUgbmV3IHdpbmRvd1xuICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd0ZlYXR1cmVzIGZlYXR1cmVzIG9mIG9wZW5lZCB3aW5kb3cgKGUuZy4gc2l6ZSwgcG9zaXRpb24sIHNjcm9sbGJhcnMsIGV0Yy4pXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgIGlkIG9mIHdpbmRvdyBoYW5kbGUgb2YgbmV3IHRhYlxuICpcbiAqIEB1c2VzIGJyb3dzZXIvZXhlY3V0ZSwgcHJvdG9jb2wvZ2V0V2luZG93SGFuZGxlcywgcHJvdG9jb2wvc3dpdGNoVG9XaW5kb3dcbiAqIEBhbGlhcyBicm93c2VyLm5ld1dpbmRvd1xuICogQHR5cGUgd2luZG93XG4gKi9cblxuaW1wb3J0IG5ld1dpbmRvd0hlbHBlciBmcm9tICcuLi8uLi9zY3JpcHRzL25ld1dpbmRvdydcbmltcG9ydCB7IG1vYmlsZURldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIG5ld1dpbmRvdyAodXJsLCB3aW5kb3dOYW1lID0gJ05ldyBXaW5kb3cnLCB3aW5kb3dGZWF0dXJlcyA9ICcnKSB7XG4gICAgLyohXG4gICAgICogcGFyYW1ldGVyIGNoZWNrXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIG9yIHR5cGUgb2YgYXJndW1lbnRzIGRvblxcJ3QgYWdyZWUgd2l0aCBuZXdXaW5kb3cgY29tbWFuZCcpXG4gICAgfVxuXG4gICAgLyohXG4gICAgICogbW9iaWxlIGNoZWNrXG4gICAgICovXG4gICAgY29uc3QgeyBpc01vYmlsZSB9ID0gbW9iaWxlRGV0ZWN0b3IodGhpcy5jYXBhYmlsaXRpZXMpXG4gICAgaWYgKGlzTW9iaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3V2luZG93IGNvbW1hbmQgaXMgbm90IHN1cHBvcnRlZCBvbiBtb2JpbGUgcGxhdGZvcm1zJylcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGUobmV3V2luZG93SGVscGVyLCB1cmwsIHdpbmRvd05hbWUsIHdpbmRvd0ZlYXR1cmVzKVxuXG4gICAgY29uc3QgdGFicyA9IGF3YWl0IHRoaXMuZ2V0V2luZG93SGFuZGxlcygpXG4gICAgY29uc3QgbmV3VGFiID0gdGFicy5wb3AoKVxuXG4gICAgYXdhaXQgdGhpcy5zd2l0Y2hUb1dpbmRvdyhuZXdUYWIpXG4gICAgcmV0dXJuIG5ld1RhYlxufVxuIl19