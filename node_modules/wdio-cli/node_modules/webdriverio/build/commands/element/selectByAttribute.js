"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = selectByAttribute;

require("source-map-support/register");

var _utils = require("../../utils");

/**
 *
 * Select option with a specific value.
 *
 * <example>
    :example.html
    <select id="selectbox">
        <option value="someValue0">uno</option>
        <option value="someValue1">dos</option>
        <option value="someValue2">tres</option>
        <option value="someValue3">cuatro</option>
        <option value="someValue4">cinco</option>
        <option name="someName5" value="someValue5">seis</option>
    </select>
    :selectByAttribute.js
    it('Should demonstrate the selectByAttribute command', () => {
        const selectBox = $('#selectbox');
        const value = selectBox.getValue();
        console.log(value); // returns "someValue0"

        selectBox.selectByAttribute('value', 'someValue3');
        console.log(selectBox.getValue()); // returns "someValue3"
        
        selectBox.selectByAttribute('name', 'someName5');
        console.log(selectBox.getValue()); // returns "someValue5"
    });
 * </example>
 *
 * @alias element.selectByAttribute
 * @param {String} attribute  attribute of option element to get selected
 * @param {String} value      value of option element to get selected
 * @uses protocol/findElementFromElement, protocol/elementClick
 * @type action
 *
 */
async function selectByAttribute(attribute, value) {
  /**
   * convert value into string
   */
  value = typeof value === 'number' ? value.toString() : value;
  /**
  * find option elememnt using xpath
  */

  const normalized = `[normalize-space(@${attribute.trim()}) = "${value.trim()}"]`;
  const optionElement = await this.findElementFromElement(this.elementId, 'xpath', `./option${normalized}|./optgroup/option${normalized}`);
  /**
  * select option
  */

  return this.elementClick((0, _utils.getElementFromResponse)(optionElement));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L3NlbGVjdEJ5QXR0cmlidXRlLmpzIl0sIm5hbWVzIjpbInNlbGVjdEJ5QXR0cmlidXRlIiwiYXR0cmlidXRlIiwidmFsdWUiLCJ0b1N0cmluZyIsIm5vcm1hbGl6ZWQiLCJ0cmltIiwib3B0aW9uRWxlbWVudCIsImZpbmRFbGVtZW50RnJvbUVsZW1lbnQiLCJlbGVtZW50SWQiLCJlbGVtZW50Q2xpY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQW9DQTs7QUFwQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NlLGVBQWVBLGlCQUFmLENBQWtDQyxTQUFsQyxFQUE2Q0MsS0FBN0MsRUFBb0Q7QUFDL0Q7OztBQUdBQSxFQUFBQSxLQUFLLEdBQUcsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixHQUNGQSxLQUFLLENBQUNDLFFBQU4sRUFERSxHQUVGRCxLQUZOO0FBSUE7Ozs7QUFHQSxRQUFNRSxVQUFVLEdBQUkscUJBQW9CSCxTQUFTLENBQUNJLElBQVYsRUFBaUIsUUFBT0gsS0FBSyxDQUFDRyxJQUFOLEVBQWEsSUFBN0U7QUFDQSxRQUFNQyxhQUFhLEdBQUcsTUFBTSxLQUFLQyxzQkFBTCxDQUE0QixLQUFLQyxTQUFqQyxFQUE0QyxPQUE1QyxFQUFzRCxXQUFVSixVQUFXLHFCQUFvQkEsVUFBVyxFQUExRyxDQUE1QjtBQUVBOzs7O0FBR0EsU0FBTyxLQUFLSyxZQUFMLENBQWtCLG1DQUF1QkgsYUFBdkIsQ0FBbEIsQ0FBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogU2VsZWN0IG9wdGlvbiB3aXRoIGEgc3BlY2lmaWMgdmFsdWUuXG4gKlxuICogPGV4YW1wbGU+XG4gICAgOmV4YW1wbGUuaHRtbFxuICAgIDxzZWxlY3QgaWQ9XCJzZWxlY3Rib3hcIj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbWVWYWx1ZTBcIj51bm88L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbWVWYWx1ZTFcIj5kb3M8L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNvbWVWYWx1ZTJcIj50cmVzPC9vcHRpb24+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJzb21lVmFsdWUzXCI+Y3VhdHJvPC9vcHRpb24+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJzb21lVmFsdWU0XCI+Y2luY288L29wdGlvbj5cbiAgICAgICAgPG9wdGlvbiBuYW1lPVwic29tZU5hbWU1XCIgdmFsdWU9XCJzb21lVmFsdWU1XCI+c2Vpczwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICAgIDpzZWxlY3RCeUF0dHJpYnV0ZS5qc1xuICAgIGl0KCdTaG91bGQgZGVtb25zdHJhdGUgdGhlIHNlbGVjdEJ5QXR0cmlidXRlIGNvbW1hbmQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdEJveCA9ICQoJyNzZWxlY3Rib3gnKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZWxlY3RCb3guZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc29sZS5sb2codmFsdWUpOyAvLyByZXR1cm5zIFwic29tZVZhbHVlMFwiXG5cbiAgICAgICAgc2VsZWN0Qm94LnNlbGVjdEJ5QXR0cmlidXRlKCd2YWx1ZScsICdzb21lVmFsdWUzJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlbGVjdEJveC5nZXRWYWx1ZSgpKTsgLy8gcmV0dXJucyBcInNvbWVWYWx1ZTNcIlxuICAgICAgICBcbiAgICAgICAgc2VsZWN0Qm94LnNlbGVjdEJ5QXR0cmlidXRlKCduYW1lJywgJ3NvbWVOYW1lNScpO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWxlY3RCb3guZ2V0VmFsdWUoKSk7IC8vIHJldHVybnMgXCJzb21lVmFsdWU1XCJcbiAgICB9KTtcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKiBAYWxpYXMgZWxlbWVudC5zZWxlY3RCeUF0dHJpYnV0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSAgYXR0cmlidXRlIG9mIG9wdGlvbiBlbGVtZW50IHRvIGdldCBzZWxlY3RlZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgICAgdmFsdWUgb2Ygb3B0aW9uIGVsZW1lbnQgdG8gZ2V0IHNlbGVjdGVkXG4gKiBAdXNlcyBwcm90b2NvbC9maW5kRWxlbWVudEZyb21FbGVtZW50LCBwcm90b2NvbC9lbGVtZW50Q2xpY2tcbiAqIEB0eXBlIGFjdGlvblxuICpcbiAqL1xuXG5pbXBvcnQgeyBnZXRFbGVtZW50RnJvbVJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHNlbGVjdEJ5QXR0cmlidXRlIChhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogY29udmVydCB2YWx1ZSBpbnRvIHN0cmluZ1xuICAgICAqL1xuICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgOiB2YWx1ZVxuXG4gICAgLyoqXG4gICAgKiBmaW5kIG9wdGlvbiBlbGVtZW1udCB1c2luZyB4cGF0aFxuICAgICovXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGBbbm9ybWFsaXplLXNwYWNlKEAke2F0dHJpYnV0ZS50cmltKCl9KSA9IFwiJHt2YWx1ZS50cmltKCl9XCJdYFxuICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBhd2FpdCB0aGlzLmZpbmRFbGVtZW50RnJvbUVsZW1lbnQodGhpcy5lbGVtZW50SWQsICd4cGF0aCcsIGAuL29wdGlvbiR7bm9ybWFsaXplZH18Li9vcHRncm91cC9vcHRpb24ke25vcm1hbGl6ZWR9YClcblxuICAgIC8qKlxuICAgICogc2VsZWN0IG9wdGlvblxuICAgICovXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudENsaWNrKGdldEVsZW1lbnRGcm9tUmVzcG9uc2Uob3B0aW9uRWxlbWVudCkpXG59XG4iXX0=