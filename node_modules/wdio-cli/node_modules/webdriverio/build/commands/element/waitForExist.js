"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitForExist;

require("source-map-support/register");

/**
 *
 * Wait for an element for the provided amount of
 * milliseconds to be present within the DOM. Returns true if the selector
 * matches at least one element that exists in the DOM, otherwise throws an
 * error. If the reverse flag is true, the command will instead return true
 * if the selector does not match any elements.
 *
 * <example>
    :waitForExistSyncExample.js
    it('should display a notification message after successful form submit', function () {
        const form = $('form');
        const notification = $('.notification');
        form.submit();
        notification.waitForExist(5000); // same as `browser.waitForExist('.notification', 5000)`
        expect(notification.getText()).to.be.equal('Data transmitted successfully!')
    });
 * </example>
 *
 * @alias element.waitForExist
 * @param {Number=}  ms       time in ms (default: 500)
 * @param {Boolean=} reverse  if true it instead waits for the selector to not match any elements (default: false)
 * @uses utility/waitUntil, state/isExisting
 * @type utility
 *
 */
function waitForExist(ms, reverse = false) {
  /*!
   * ensure that ms is set properly
   */
  if (typeof ms !== 'number') {
    ms = this.options.waitforTimeout;
  }

  const isReversed = reverse ? '' : 'not ';
  const errorMsg = `element ("${this.selector}") still ${isReversed}existing after ${ms}ms`;
  return this.waitUntil(function async() {
    return this.isExisting().then(isExisting => isExisting !== reverse);
  }, ms, errorMsg);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L3dhaXRGb3JFeGlzdC5qcyJdLCJuYW1lcyI6WyJ3YWl0Rm9yRXhpc3QiLCJtcyIsInJldmVyc2UiLCJvcHRpb25zIiwid2FpdGZvclRpbWVvdXQiLCJpc1JldmVyc2VkIiwiZXJyb3JNc2ciLCJzZWxlY3RvciIsIndhaXRVbnRpbCIsImFzeW5jIiwiaXNFeGlzdGluZyIsInRoZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCZSxTQUFTQSxZQUFULENBQXVCQyxFQUF2QixFQUEyQkMsT0FBTyxHQUFHLEtBQXJDLEVBQTRDO0FBQ3ZEOzs7QUFHQSxNQUFJLE9BQU9ELEVBQVAsS0FBYyxRQUFsQixFQUE0QjtBQUN4QkEsSUFBQUEsRUFBRSxHQUFHLEtBQUtFLE9BQUwsQ0FBYUMsY0FBbEI7QUFDSDs7QUFFRCxRQUFNQyxVQUFVLEdBQUdILE9BQU8sR0FBRyxFQUFILEdBQVEsTUFBbEM7QUFDQSxRQUFNSSxRQUFRLEdBQUksYUFBWSxLQUFLQyxRQUFTLFlBQVdGLFVBQVcsa0JBQWlCSixFQUFHLElBQXRGO0FBRUEsU0FBTyxLQUFLTyxTQUFMLENBQWUsU0FBU0MsS0FBVCxHQUFrQjtBQUNwQyxXQUFPLEtBQUtDLFVBQUwsR0FBa0JDLElBQWxCLENBQXdCRCxVQUFELElBQWdCQSxVQUFVLEtBQUtSLE9BQXRELENBQVA7QUFDSCxHQUZNLEVBRUpELEVBRkksRUFFQUssUUFGQSxDQUFQO0FBR0giLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICpcbiAqIFdhaXQgZm9yIGFuIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcyB0byBiZSBwcmVzZW50IHdpdGhpbiB0aGUgRE9NLiBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbGVjdG9yXG4gKiBtYXRjaGVzIGF0IGxlYXN0IG9uZSBlbGVtZW50IHRoYXQgZXhpc3RzIGluIHRoZSBET00sIG90aGVyd2lzZSB0aHJvd3MgYW5cbiAqIGVycm9yLiBJZiB0aGUgcmV2ZXJzZSBmbGFnIGlzIHRydWUsIHRoZSBjb21tYW5kIHdpbGwgaW5zdGVhZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIHNlbGVjdG9yIGRvZXMgbm90IG1hdGNoIGFueSBlbGVtZW50cy5cbiAqXG4gKiA8ZXhhbXBsZT5cbiAgICA6d2FpdEZvckV4aXN0U3luY0V4YW1wbGUuanNcbiAgICBpdCgnc2hvdWxkIGRpc3BsYXkgYSBub3RpZmljYXRpb24gbWVzc2FnZSBhZnRlciBzdWNjZXNzZnVsIGZvcm0gc3VibWl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBmb3JtID0gJCgnZm9ybScpO1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSAkKCcubm90aWZpY2F0aW9uJyk7XG4gICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgIG5vdGlmaWNhdGlvbi53YWl0Rm9yRXhpc3QoNTAwMCk7IC8vIHNhbWUgYXMgYGJyb3dzZXIud2FpdEZvckV4aXN0KCcubm90aWZpY2F0aW9uJywgNTAwMClgXG4gICAgICAgIGV4cGVjdChub3RpZmljYXRpb24uZ2V0VGV4dCgpKS50by5iZS5lcXVhbCgnRGF0YSB0cmFuc21pdHRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICB9KTtcbiAqIDwvZXhhbXBsZT5cbiAqXG4gKiBAYWxpYXMgZWxlbWVudC53YWl0Rm9yRXhpc3RcbiAqIEBwYXJhbSB7TnVtYmVyPX0gIG1zICAgICAgIHRpbWUgaW4gbXMgKGRlZmF1bHQ6IDUwMClcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IHJldmVyc2UgIGlmIHRydWUgaXQgaW5zdGVhZCB3YWl0cyBmb3IgdGhlIHNlbGVjdG9yIHRvIG5vdCBtYXRjaCBhbnkgZWxlbWVudHMgKGRlZmF1bHQ6IGZhbHNlKVxuICogQHVzZXMgdXRpbGl0eS93YWl0VW50aWwsIHN0YXRlL2lzRXhpc3RpbmdcbiAqIEB0eXBlIHV0aWxpdHlcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FpdEZvckV4aXN0IChtcywgcmV2ZXJzZSA9IGZhbHNlKSB7XG4gICAgLyohXG4gICAgICogZW5zdXJlIHRoYXQgbXMgaXMgc2V0IHByb3Blcmx5XG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBtcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgbXMgPSB0aGlzLm9wdGlvbnMud2FpdGZvclRpbWVvdXRcbiAgICB9XG5cbiAgICBjb25zdCBpc1JldmVyc2VkID0gcmV2ZXJzZSA/ICcnIDogJ25vdCAnXG4gICAgY29uc3QgZXJyb3JNc2cgPSBgZWxlbWVudCAoXCIke3RoaXMuc2VsZWN0b3J9XCIpIHN0aWxsICR7aXNSZXZlcnNlZH1leGlzdGluZyBhZnRlciAke21zfW1zYFxuXG4gICAgcmV0dXJuIHRoaXMud2FpdFVudGlsKGZ1bmN0aW9uIGFzeW5jICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFeGlzdGluZygpLnRoZW4oKGlzRXhpc3RpbmcpID0+IGlzRXhpc3RpbmcgIT09IHJldmVyc2UpXG4gICAgfSwgbXMsIGVycm9yTXNnKVxufVxuIl19