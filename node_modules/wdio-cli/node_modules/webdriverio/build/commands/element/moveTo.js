"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = moveTo;

require("source-map-support/register");

/**
 *
 * Move the mouse by an offset of the specified element. If no element is specified,
 * the move is relative to the current mouse cursor. If an element is provided but
 * no offset, the mouse will be moved to the center of the element. If the element
 * is not visible, it will be scrolled into view.
 *
 * @param {Number} xoffset  X offset to move to, relative to the top-left corner of the element. If not specified, the mouse will move to the middle of the element.
 * @param {Number} yoffset  Y offset to move to, relative to the top-left corner of the element. If not specified, the mouse will move to the middle of the element.
 *
 * @see  https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#sessionsessionidmoveto
 * @type protocol
 */
async function moveTo(xoffset, yoffset) {
  if (!this.isW3C) {
    return this.moveToElement(this.elementId, xoffset, yoffset);
  }
  /**
   * get rect of element
   */


  const {
    x,
    y,
    width,
    height
  } = await this.getElementRect(this.elementId);
  const newXoffset = parseInt(x + (typeof xoffset === 'number' ? xoffset : width / 2), 10);
  const newYoffset = parseInt(y + (typeof yoffset === 'number' ? yoffset : height / 2), 10);
  /**
   * W3C way of handle the mouse move actions
   */

  return this.performActions([{
    type: 'pointer',
    id: 'finger1',
    parameters: {
      pointerType: 'mouse'
    },
    actions: [{
      type: 'pointerMove',
      duration: 0,
      x: newXoffset,
      y: newYoffset
    }]
  }]).then(() => this.releaseActions());
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tYW5kcy9lbGVtZW50L21vdmVUby5qcyJdLCJuYW1lcyI6WyJtb3ZlVG8iLCJ4b2Zmc2V0IiwieW9mZnNldCIsImlzVzNDIiwibW92ZVRvRWxlbWVudCIsImVsZW1lbnRJZCIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJnZXRFbGVtZW50UmVjdCIsIm5ld1hvZmZzZXQiLCJwYXJzZUludCIsIm5ld1lvZmZzZXQiLCJwZXJmb3JtQWN0aW9ucyIsInR5cGUiLCJpZCIsInBhcmFtZXRlcnMiLCJwb2ludGVyVHlwZSIsImFjdGlvbnMiLCJkdXJhdGlvbiIsInRoZW4iLCJyZWxlYXNlQWN0aW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFhZSxlQUFlQSxNQUFmLENBQXVCQyxPQUF2QixFQUFnQ0MsT0FBaEMsRUFBeUM7QUFDcEQsTUFBSSxDQUFDLEtBQUtDLEtBQVYsRUFBaUI7QUFDYixXQUFPLEtBQUtDLGFBQUwsQ0FBbUIsS0FBS0MsU0FBeEIsRUFBbUNKLE9BQW5DLEVBQTRDQyxPQUE1QyxDQUFQO0FBQ0g7QUFFRDs7Ozs7QUFHQSxRQUFNO0FBQUVJLElBQUFBLENBQUY7QUFBS0MsSUFBQUEsQ0FBTDtBQUFRQyxJQUFBQSxLQUFSO0FBQWVDLElBQUFBO0FBQWYsTUFBMEIsTUFBTSxLQUFLQyxjQUFMLENBQW9CLEtBQUtMLFNBQXpCLENBQXRDO0FBQ0EsUUFBTU0sVUFBVSxHQUFHQyxRQUFRLENBQUNOLENBQUMsSUFBSSxPQUFPTCxPQUFQLEtBQW1CLFFBQW5CLEdBQThCQSxPQUE5QixHQUF5Q08sS0FBSyxHQUFHLENBQXJELENBQUYsRUFBNEQsRUFBNUQsQ0FBM0I7QUFDQSxRQUFNSyxVQUFVLEdBQUdELFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJLE9BQU9MLE9BQVAsS0FBbUIsUUFBbkIsR0FBOEJBLE9BQTlCLEdBQXlDTyxNQUFNLEdBQUcsQ0FBdEQsQ0FBRixFQUE2RCxFQUE3RCxDQUEzQjtBQUVBOzs7O0FBR0EsU0FBTyxLQUFLSyxjQUFMLENBQW9CLENBQUM7QUFDeEJDLElBQUFBLElBQUksRUFBRSxTQURrQjtBQUV4QkMsSUFBQUEsRUFBRSxFQUFFLFNBRm9CO0FBR3hCQyxJQUFBQSxVQUFVLEVBQUU7QUFBRUMsTUFBQUEsV0FBVyxFQUFFO0FBQWYsS0FIWTtBQUl4QkMsSUFBQUEsT0FBTyxFQUFFLENBQUM7QUFBQ0osTUFBQUEsSUFBSSxFQUFFLGFBQVA7QUFBc0JLLE1BQUFBLFFBQVEsRUFBRSxDQUFoQztBQUFtQ2QsTUFBQUEsQ0FBQyxFQUFFSyxVQUF0QztBQUFrREosTUFBQUEsQ0FBQyxFQUFFTTtBQUFyRCxLQUFEO0FBSmUsR0FBRCxDQUFwQixFQUtIUSxJQUxHLENBS0UsTUFBTSxLQUFLQyxjQUFMLEVBTFIsQ0FBUDtBQU1IIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogTW92ZSB0aGUgbW91c2UgYnkgYW4gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gSWYgbm8gZWxlbWVudCBpcyBzcGVjaWZpZWQsXG4gKiB0aGUgbW92ZSBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBtb3VzZSBjdXJzb3IuIElmIGFuIGVsZW1lbnQgaXMgcHJvdmlkZWQgYnV0XG4gKiBubyBvZmZzZXQsIHRoZSBtb3VzZSB3aWxsIGJlIG1vdmVkIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50XG4gKiBpcyBub3QgdmlzaWJsZSwgaXQgd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhvZmZzZXQgIFggb2Zmc2V0IHRvIG1vdmUgdG8sIHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnQuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBtb3VzZSB3aWxsIG1vdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5b2Zmc2V0ICBZIG9mZnNldCB0byBtb3ZlIHRvLCByZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgbW91c2Ugd2lsbCBtb3ZlIHRvIHRoZSBtaWRkbGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHNlZSAgaHR0cHM6Ly9naXRodWIuY29tL1NlbGVuaXVtSFEvc2VsZW5pdW0vd2lraS9Kc29uV2lyZVByb3RvY29sI3Nlc3Npb25zZXNzaW9uaWRtb3ZldG9cbiAqIEB0eXBlIHByb3RvY29sXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIG1vdmVUbyAoeG9mZnNldCwgeW9mZnNldCkge1xuICAgIGlmICghdGhpcy5pc1czQykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlVG9FbGVtZW50KHRoaXMuZWxlbWVudElkLCB4b2Zmc2V0LCB5b2Zmc2V0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCByZWN0IG9mIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGF3YWl0IHRoaXMuZ2V0RWxlbWVudFJlY3QodGhpcy5lbGVtZW50SWQpXG4gICAgY29uc3QgbmV3WG9mZnNldCA9IHBhcnNlSW50KHggKyAodHlwZW9mIHhvZmZzZXQgPT09ICdudW1iZXInID8geG9mZnNldCA6ICh3aWR0aCAvIDIpKSwgMTApXG4gICAgY29uc3QgbmV3WW9mZnNldCA9IHBhcnNlSW50KHkgKyAodHlwZW9mIHlvZmZzZXQgPT09ICdudW1iZXInID8geW9mZnNldCA6IChoZWlnaHQgLyAyKSksIDEwKVxuXG4gICAgLyoqXG4gICAgICogVzNDIHdheSBvZiBoYW5kbGUgdGhlIG1vdXNlIG1vdmUgYWN0aW9uc1xuICAgICAqL1xuICAgIHJldHVybiB0aGlzLnBlcmZvcm1BY3Rpb25zKFt7XG4gICAgICAgIHR5cGU6ICdwb2ludGVyJyxcbiAgICAgICAgaWQ6ICdmaW5nZXIxJyxcbiAgICAgICAgcGFyYW1ldGVyczogeyBwb2ludGVyVHlwZTogJ21vdXNlJyB9LFxuICAgICAgICBhY3Rpb25zOiBbe3R5cGU6ICdwb2ludGVyTW92ZScsIGR1cmF0aW9uOiAwLCB4OiBuZXdYb2Zmc2V0LCB5OiBuZXdZb2Zmc2V0fV1cbiAgICB9XSkudGhlbigoKSA9PiB0aGlzLnJlbGVhc2VBY3Rpb25zKCkpXG59XG4iXX0=