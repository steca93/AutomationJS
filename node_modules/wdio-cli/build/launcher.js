'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sourceMapSupport2 = require('source-map-support');

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _wdioLogger = require('wdio-logger');

var _wdioLogger2 = _interopRequireDefault(_wdioLogger);

var _wdioConfig = require('wdio-config');

var _interface = require('./interface');

var _interface2 = _interopRequireDefault(_interface);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

(0, _sourceMapSupport2.install)();


const log = (0, _wdioLogger2.default)('wdio-cli:Launcher');

class Launcher {
    constructor(configFile, argv) {
        var _context;

        this.configParser = new _wdioConfig.ConfigParser();
        this.configParser.addConfigFile(configFile);
        this.configParser.merge(argv);

        const config = this.configParser.getConfig();
        const capabilities = this.configParser.getCapabilities();
        const specs = this.configParser.getSpecs();

        if (config.logDir) {
            process.env.WDIO_LOG_PATH = _path2.default.join(config.logDir, `wdio.log`);
        }

        this.interface = new _interface2.default(config, specs);
        config.runnerEnv.FORCE_COLOR = Number(this.interface.hasAnsiSupport);

        const Runner = (0, _wdioConfig.initialisePlugin)(config.runner, 'runner');
        this.runner = new Runner(configFile, config);
        this.runner.on('end', this.endHandler.bind(this));
        this.runner.on('message', (_context = this.interface).onMessage.bind(_context));

        this.argv = argv;
        this.configFile = configFile;

        this.isMultiremote = !Array.isArray(capabilities);
        this.exitCode = 0;
        this.hasTriggeredExitRoutine = false;
        this.hasStartedAnyProcess = false;
        this.schedule = [];
        this.rid = [];
        this.runnerStarted = 0;
        this.runnerFailed = 0;
    }

    /**
     * run sequence
     * @return  {Promise} that only gets resolves with either an exitCode or an error
     */
    run() {
        var _this = this;

        return _asyncToGenerator(function* () {
            let config = _this.configParser.getConfig();
            let caps = _this.configParser.getCapabilities();
            let launcher = (0, _utils.getLauncher)(config);

            yield _this.runner.initialise();

            /**
             * run onPrepare hook
             */
            yield config.onPrepare(config, caps);
            log.info('Run onPrepare hook');
            yield (0, _utils.runServiceHook)(launcher, 'onPrepare', config, caps);

            /**
             * if it is an object run multiremote test
             */
            if (_this.isMultiremote) {
                let exitCode = yield new Promise(function (resolve) {
                    _this.resolve = resolve;
                    _this.startInstance(_this.configParser.getSpecs(), caps, 0);
                });

                /**
                 * run onComplete hook for multiremote
                 */
                log.info('Run multiremote onComplete hook');
                yield (0, _utils.runServiceHook)(launcher, 'onComplete', exitCode, config, caps);
                yield config.onComplete(exitCode, config, caps);

                return exitCode;
            }

            /**
             * schedule test runs
             */
            let cid = 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = caps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    let capabilities = _step.value;

                    _this.schedule.push({
                        cid: cid++,
                        caps: capabilities,
                        specs: _this.configParser.getSpecs(capabilities.specs, capabilities.exclude),
                        availableInstances: capabilities.maxInstances || config.maxInstancesPerCapability,
                        runningInstances: 0,
                        seleniumServer: { hostname: config.hostname, port: config.port, protocol: config.protocol }
                    });
                }

                /**
                 * catches ctrl+c event
                 */
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            process.on('SIGINT', _this.exitHandler.bind(_this));

            /**
             * make sure the program will not close instantly
             */
            if (process.stdin.isPaused()) {
                process.stdin.resume();
            }

            const exitCode = yield new Promise(function (resolve) {
                _this.resolve = resolve;

                /**
                 * fail if no specs were found or specified
                 */
                if (Object.values(_this.schedule).reduce(function (specCnt, schedule) {
                    return specCnt + schedule.specs.length;
                }, 0) === 0) {
                    log.error('No specs found to run, exiting with failure');
                    _this.interface.updateView();
                    return resolve(1);
                }

                /**
                 * return immediately if no spec was run
                 */
                if (_this.runSpecs()) {
                    resolve(0);
                }
            });

            /**
             * run onComplete hook
             */
            log.info('Run onComplete hook');
            yield (0, _utils.runServiceHook)(launcher, 'onComplete', exitCode, config, caps);
            yield config.onComplete(exitCode, config, caps);

            _this.interface.updateView();
            return exitCode;
        })();
    }

    /**
     * run multiple single remote tests
     * @return {Boolean} true if all specs have been run and all instances have finished
     */
    runSpecs() {
        let config = this.configParser.getConfig();

        /**
         * stop spawning new processes when CTRL+C was triggered
         */
        if (this.hasTriggeredExitRoutine) {
            return true;
        }

        while (this.getNumberOfRunningInstances() < config.maxInstances) {
            let schedulableCaps = this.schedule
            /**
             * bail if number of errors exceeds allowed
             */
            .filter(() => {
                const filter = typeof config.bail !== 'number' || config.bail < 1 || config.bail > this.runnerFailed;

                /**
                 * clear number of specs when filter is false
                 */
                if (!filter) {
                    this.schedule.forEach(t => {
                        t.specs = [];
                    });
                }

                return filter;
            })
            /**
             * make sure complete number of running instances is not higher than general maxInstances number
             */
            .filter(() => this.getNumberOfRunningInstances() < config.maxInstances)
            /**
             * make sure the capability has available capacities
             */
            .filter(a => a.availableInstances > 0)
            /**
             * make sure capability has still caps to run
             */
            .filter(a => a.specs.length > 0)
            /**
             * make sure we are running caps with less running instances first
             */
            .sort((a, b) => a.runningInstances > b.runningInstances);

            /**
             * continue if no capability were schedulable
             */
            if (schedulableCaps.length === 0) {
                break;
            }

            this.startInstance([schedulableCaps[0].specs.shift()], schedulableCaps[0].caps, schedulableCaps[0].cid, schedulableCaps[0].seleniumServer);
            schedulableCaps[0].availableInstances--;
            schedulableCaps[0].runningInstances++;
        }

        return this.getNumberOfRunningInstances() === 0 && this.getNumberOfSpecsLeft() === 0;
    }

    /**
     * gets number of all running instances
     * @return {number} number of running instances
     */
    getNumberOfRunningInstances() {
        return this.schedule.map(a => a.runningInstances).reduce((a, b) => a + b);
    }

    /**
     * get number of total specs left to complete whole suites
     * @return {number} specs left to complete suite
     */
    getNumberOfSpecsLeft() {
        return this.schedule.map(a => a.specs.length).reduce((a, b) => a + b);
    }

    /**
     * Start instance in a child process.
     * @param  {Array} specs  Specs to run
     * @param  {Number} cid  Capabilities ID
     */
    startInstance(specs, caps, cid, server) {
        let config = this.configParser.getConfig();
        cid = this.getRunnerId(cid);
        let processNumber = this.runnerStarted + 1;

        // process.debugPort defaults to 5858 and is set even when process
        // is not being debugged.
        let debugArgs = [];
        let debugType;
        let debugHost = '';
        let debugPort = process.debugPort;
        for (let i in process.execArgv) {
            const debugArgs = process.execArgv[i].match('--(debug|inspect)(?:-brk)?(?:=(.*):)?');
            if (debugArgs) {
                var _debugArgs = _slicedToArray(debugArgs, 3);

                let type = _debugArgs[1],
                    host = _debugArgs[2];

                if (type) {
                    debugType = type;
                }
                if (host) {
                    debugHost = `${host}:`;
                }
            }
        }

        if (debugType) {
            debugArgs.push(`--${debugType}=${debugHost}${debugPort + processNumber}`);
        }

        // if you would like to add --debug-brk, use a different port, etc...
        let capExecArgs = [...(config.execArgv || []), ...(caps.execArgv || [])];

        // The default value for child.fork execArgs is process.execArgs,
        // so continue to use this unless another value is specified in config.
        let defaultArgs = capExecArgs.length ? process.execArgv : [];

        // If an arg appears multiple times the last occurrence is used
        let execArgv = [...defaultArgs, ...debugArgs, ...capExecArgs];

        // prefer launcher settings in capabilities over general launcher
        this.runner.run({
            cid,
            command: 'run',
            configFile: this.configFile,
            argv: this.argv,
            caps,
            processNumber,
            specs,
            server,
            isMultiremote: this.isMultiremote,
            execArgv
        });

        this.interface.emit('job:start', { cid, caps, specs });
        this.runnerStarted++;
    }

    /**
     * generates a runner id
     * @param  {Number} cid capability id (unique identifier for a capability)
     * @return {String}     runner id (combination of cid and test id e.g. 0a, 0b, 1a, 1b ...)
     */
    getRunnerId(cid) {
        if (!this.rid[cid]) {
            this.rid[cid] = 0;
        }
        return `${cid}-${this.rid[cid]++}`;
    }

    /**
     * Close test runner process once all child processes have exited
     * @param  {Number} cid       Capabilities ID
     * @param  {Number} exitCode  exit code of child process
     */
    endHandler({ cid, exitCode }) {
        const passed = exitCode === 0;
        this.exitCode = this.exitCode || exitCode;
        this.runnerFailed += !passed ? 1 : 0;
        this.interface.emit('job:end', { cid, passed });

        // Update schedule now this process has ended
        if (!this.isMultiremote) {
            // get cid (capability id) from rid (runner id)
            cid = parseInt(cid, 10);

            this.schedule[cid].availableInstances++;
            this.schedule[cid].runningInstances--;
        }

        if (!this.isMultiremote && !this.runSpecs()) {
            return;
        }

        if (passed) {
            return process.nextTick(() => {
                this.interface.updateView();
                setTimeout(() => this.resolve(this.exitCode), 100);
            });
        }

        /**
         * finish with exit code 1
         */
        return process.nextTick(() => {
            this.interface.updateView();
            setTimeout(() => this.resolve(1), 100);
        });
    }

    /**
     * Make sure all started selenium sessions get closed properly and prevent
     * having dead driver processes. To do so let the runner end its Selenium
     * session first before killing
     */
    exitHandler() {
        if (this.hasTriggeredExitRoutine || !this.hasStartedAnyProcess) {
            log.log('\nKilling process, bye!');

            // When spawned as a subprocess,
            // SIGINT will not be forwarded to childs.
            // Thus for the child to exit cleanly, we must force send SIGINT
            if (!process.stdin.isTTY) {
                this.runner.kill();
            }

            // finish with exit code 1
            return this.resolve(1);
        }

        // When spawned as a subprocess,
        // SIGINT will not be forwarded to childs.
        // Thus for the child to exit cleanly, we must force send SIGINT
        if (!process.stdin.isTTY) {
            this.runner.kill();
        }

        log.log(`

End selenium sessions properly ...
(press ctrl+c again to hard kill the runner)
`);

        this.hasTriggeredExitRoutine = true;
    }
}

exports.default = Launcher;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXVuY2hlci5qcyJdLCJuYW1lcyI6WyJsb2ciLCJMYXVuY2hlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmlsZSIsImFyZ3YiLCJjb25maWdQYXJzZXIiLCJDb25maWdQYXJzZXIiLCJhZGRDb25maWdGaWxlIiwibWVyZ2UiLCJjb25maWciLCJnZXRDb25maWciLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJzcGVjcyIsImdldFNwZWNzIiwibG9nRGlyIiwicHJvY2VzcyIsImVudiIsIldESU9fTE9HX1BBVEgiLCJwYXRoIiwiam9pbiIsImludGVyZmFjZSIsIkNMSW50ZXJmYWNlIiwicnVubmVyRW52IiwiRk9SQ0VfQ09MT1IiLCJOdW1iZXIiLCJoYXNBbnNpU3VwcG9ydCIsIlJ1bm5lciIsInJ1bm5lciIsIm9uIiwiZW5kSGFuZGxlciIsIm9uTWVzc2FnZSIsImlzTXVsdGlyZW1vdGUiLCJBcnJheSIsImlzQXJyYXkiLCJleGl0Q29kZSIsImhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lIiwiaGFzU3RhcnRlZEFueVByb2Nlc3MiLCJzY2hlZHVsZSIsInJpZCIsInJ1bm5lclN0YXJ0ZWQiLCJydW5uZXJGYWlsZWQiLCJydW4iLCJjYXBzIiwibGF1bmNoZXIiLCJpbml0aWFsaXNlIiwib25QcmVwYXJlIiwiaW5mbyIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhcnRJbnN0YW5jZSIsIm9uQ29tcGxldGUiLCJjaWQiLCJwdXNoIiwiZXhjbHVkZSIsImF2YWlsYWJsZUluc3RhbmNlcyIsIm1heEluc3RhbmNlcyIsIm1heEluc3RhbmNlc1BlckNhcGFiaWxpdHkiLCJydW5uaW5nSW5zdGFuY2VzIiwic2VsZW5pdW1TZXJ2ZXIiLCJob3N0bmFtZSIsInBvcnQiLCJwcm90b2NvbCIsImV4aXRIYW5kbGVyIiwiYmluZCIsInN0ZGluIiwiaXNQYXVzZWQiLCJyZXN1bWUiLCJPYmplY3QiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzcGVjQ250IiwibGVuZ3RoIiwiZXJyb3IiLCJ1cGRhdGVWaWV3IiwicnVuU3BlY3MiLCJnZXROdW1iZXJPZlJ1bm5pbmdJbnN0YW5jZXMiLCJzY2hlZHVsYWJsZUNhcHMiLCJmaWx0ZXIiLCJiYWlsIiwiZm9yRWFjaCIsInQiLCJhIiwic29ydCIsImIiLCJzaGlmdCIsImdldE51bWJlck9mU3BlY3NMZWZ0IiwibWFwIiwic2VydmVyIiwiZ2V0UnVubmVySWQiLCJwcm9jZXNzTnVtYmVyIiwiZGVidWdBcmdzIiwiZGVidWdUeXBlIiwiZGVidWdIb3N0IiwiZGVidWdQb3J0IiwiaSIsImV4ZWNBcmd2IiwibWF0Y2giLCJ0eXBlIiwiaG9zdCIsImNhcEV4ZWNBcmdzIiwiZGVmYXVsdEFyZ3MiLCJjb21tYW5kIiwiZW1pdCIsInBhc3NlZCIsInBhcnNlSW50IiwibmV4dFRpY2siLCJzZXRUaW1lb3V0IiwiaXNUVFkiLCJraWxsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7OztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7Ozs7OztBQUVBLE1BQU1BLE1BQU0sMEJBQU8sbUJBQVAsQ0FBWjs7QUFFQSxNQUFNQyxRQUFOLENBQWU7QUFDWEMsZ0JBQWFDLFVBQWIsRUFBeUJDLElBQXpCLEVBQStCO0FBQUE7O0FBQzNCLGFBQUtDLFlBQUwsR0FBb0IsSUFBSUMsd0JBQUosRUFBcEI7QUFDQSxhQUFLRCxZQUFMLENBQWtCRSxhQUFsQixDQUFnQ0osVUFBaEM7QUFDQSxhQUFLRSxZQUFMLENBQWtCRyxLQUFsQixDQUF3QkosSUFBeEI7O0FBRUEsY0FBTUssU0FBUyxLQUFLSixZQUFMLENBQWtCSyxTQUFsQixFQUFmO0FBQ0EsY0FBTUMsZUFBZSxLQUFLTixZQUFMLENBQWtCTyxlQUFsQixFQUFyQjtBQUNBLGNBQU1DLFFBQVEsS0FBS1IsWUFBTCxDQUFrQlMsUUFBbEIsRUFBZDs7QUFFQSxZQUFJTCxPQUFPTSxNQUFYLEVBQW1CO0FBQ2ZDLG9CQUFRQyxHQUFSLENBQVlDLGFBQVosR0FBNEJDLGVBQUtDLElBQUws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LE1BQUwsQ0FBWWlGLElBQVo7QUFDSDs7QUFFRDdHLFlBQUlBLEdBQUosQ0FBUzs7OztDQUFUOztBQU1BLGFBQUtvQyx1QkFBTCxHQUErQixJQUEvQjtBQUNIO0FBN1dVOztrQkFnWEFuQyxRIiwiZmlsZSI6ImxhdW5jaGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcblxuaW1wb3J0IGxvZ2dlciBmcm9tICd3ZGlvLWxvZ2dlcidcbmltcG9ydCB7IENvbmZpZ1BhcnNlciwgaW5pdGlhbGlzZVBsdWdpbiB9IGZyb20gJ3dkaW8tY29uZmlnJ1xuXG5pbXBvcnQgQ0xJbnRlcmZhY2UgZnJvbSAnLi9pbnRlcmZhY2UnXG5pbXBvcnQgeyBnZXRMYXVuY2hlciwgcnVuU2VydmljZUhvb2sgfSBmcm9tICcuL3V0aWxzJ1xuXG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dkaW8tY2xpOkxhdW5jaGVyJylcblxuY2xhc3MgTGF1bmNoZXIge1xuICAgIGNvbnN0cnVjdG9yIChjb25maWdGaWxlLCBhcmd2KSB7XG4gICAgICAgIHRoaXMuY29uZmlnUGFyc2VyID0gbmV3IENvbmZpZ1BhcnNlcigpXG4gICAgICAgIHRoaXMuY29uZmlnUGFyc2VyLmFkZENvbmZpZ0ZpbGUoY29uZmlnRmlsZSlcbiAgICAgICAgdGhpcy5jb25maWdQYXJzZXIubWVyZ2UoYXJndilcblxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRDb25maWcoKVxuICAgICAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRDYXBhYmlsaXRpZXMoKVxuICAgICAgICBjb25zdCBzcGVjcyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldFNwZWNzKClcblxuICAgICAgICBpZiAoY29uZmlnLmxvZ0Rpcikge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuV0RJT19MT0dfUEFUSCA9IHBhdGguam9pbihjb25maWcubG9nRGlyLCBgd2Rpby5sb2dgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcmZhY2UgPSBuZXcgQ0xJbnRlcmZhY2UoY29uZmlnLCBzcGVjcylcbiAgICAgICAgY29uZmlnLnJ1bm5lckVudi5GT1JDRV9DT0xPUiA9IE51bWJlcih0aGlzLmludGVyZmFjZS5oYXNBbnNpU3VwcG9ydClcblxuICAgICAgICBjb25zdCBSdW5uZXIgPSBpbml0aWFsaXNlUGx1Z2luKGNvbmZpZy5ydW5uZXIsICdydW5uZXInKVxuICAgICAgICB0aGlzLnJ1bm5lciA9IG5ldyBSdW5uZXIoY29uZmlnRmlsZSwgY29uZmlnKVxuICAgICAgICB0aGlzLnJ1bm5lci5vbignZW5kJywgOjp0aGlzLmVuZEhhbmRsZXIpXG4gICAgICAgIHRoaXMucnVubmVyLm9uKCdtZXNzYWdlJywgOjp0aGlzLmludGVyZmFjZS5vbk1lc3NhZ2UpXG5cbiAgICAgICAgdGhpcy5hcmd2ID0gYXJndlxuICAgICAgICB0aGlzLmNvbmZpZ0ZpbGUgPSBjb25maWdGaWxlXG5cbiAgICAgICAgdGhpcy5pc011bHRpcmVtb3RlID0gIUFycmF5LmlzQXJyYXkoY2FwYWJpbGl0aWVzKVxuICAgICAgICB0aGlzLmV4aXRDb2RlID0gMFxuICAgICAgICB0aGlzLmhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkQW55UHJvY2VzcyA9IGZhbHNlXG4gICAgICAgIHRoaXMuc2NoZWR1bGUgPSBbXVxuICAgICAgICB0aGlzLnJpZCA9IFtdXG4gICAgICAgIHRoaXMucnVubmVyU3RhcnRlZCA9IDBcbiAgICAgICAgdGhpcy5ydW5uZXJGYWlsZWQgPSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIHNlcXVlbmNlXG4gICAgICogQHJldHVybiAge1Byb21pc2V9IHRoYXQgb25seSBnZXRzIHJlc29sdmVzIHdpdGggZWl0aGVyIGFuIGV4aXRDb2RlIG9yIGFuIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgcnVuICgpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG4gICAgICAgIGxldCBjYXBzID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q2FwYWJpbGl0aWVzKClcbiAgICAgICAgbGV0IGxhdW5jaGVyID0gZ2V0TGF1bmNoZXIoY29uZmlnKVxuXG4gICAgICAgIGF3YWl0IHRoaXMucnVubmVyLmluaXRpYWxpc2UoKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBydW4gb25QcmVwYXJlIGhvb2tcbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IGNvbmZpZy5vblByZXBhcmUoY29uZmlnLCBjYXBzKVxuICAgICAgICBsb2cuaW5mbygnUnVuIG9uUHJlcGFyZSBob29rJylcbiAgICAgICAgYXdhaXQgcnVuU2VydmljZUhvb2sobGF1bmNoZXIsICdvblByZXBhcmUnLCBjb25maWcsIGNhcHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIGl0IGlzIGFuIG9iamVjdCBydW4gbXVsdGlyZW1vdGUgdGVzdFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aXJlbW90ZSkge1xuICAgICAgICAgICAgbGV0IGV4aXRDb2RlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEluc3RhbmNlKHRoaXMuY29uZmlnUGFyc2VyLmdldFNwZWNzKCksIGNhcHMsIDApXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJ1biBvbkNvbXBsZXRlIGhvb2sgZm9yIG11bHRpcmVtb3RlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxvZy5pbmZvKCdSdW4gbXVsdGlyZW1vdGUgb25Db21wbGV0ZSBob29rJylcbiAgICAgICAgICAgIGF3YWl0IHJ1blNlcnZpY2VIb29rKGxhdW5jaGVyLCAnb25Db21wbGV0ZScsIGV4aXRDb2RlLCBjb25maWcsIGNhcHMpXG4gICAgICAgICAgICBhd2FpdCBjb25maWcub25Db21wbGV0ZShleGl0Q29kZSwgY29uZmlnLCBjYXBzKVxuXG4gICAgICAgICAgICByZXR1cm4gZXhpdENvZGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzY2hlZHVsZSB0ZXN0IHJ1bnNcbiAgICAgICAgICovXG4gICAgICAgIGxldCBjaWQgPSAwXG4gICAgICAgIGZvciAobGV0IGNhcGFiaWxpdGllcyBvZiBjYXBzKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlLnB1c2goe1xuICAgICAgICAgICAgICAgIGNpZDogY2lkKyssXG4gICAgICAgICAgICAgICAgY2FwczogY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgIHNwZWNzOiB0aGlzLmNvbmZpZ1BhcnNlci5nZXRTcGVjcyhjYXBhYmlsaXRpZXMuc3BlY3MsIGNhcGFiaWxpdGllcy5leGNsdWRlKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVJbnN0YW5jZXM6IGNhcGFiaWxpdGllcy5tYXhJbnN0YW5jZXMgfHwgY29uZmlnLm1heEluc3RhbmNlc1BlckNhcGFiaWxpdHksXG4gICAgICAgICAgICAgICAgcnVubmluZ0luc3RhbmNlczogMCxcbiAgICAgICAgICAgICAgICBzZWxlbml1bVNlcnZlcjogeyBob3N0bmFtZTogY29uZmlnLmhvc3RuYW1lLCBwb3J0OiBjb25maWcucG9ydCwgcHJvdG9jb2w6IGNvbmZpZy5wcm90b2NvbCB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhdGNoZXMgY3RybCtjIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzLm9uKCdTSUdJTlQnLCB0aGlzLmV4aXRIYW5kbGVyLmJpbmQodGhpcykpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ha2Ugc3VyZSB0aGUgcHJvZ3JhbSB3aWxsIG5vdCBjbG9zZSBpbnN0YW50bHlcbiAgICAgICAgICovXG4gICAgICAgIGlmIChwcm9jZXNzLnN0ZGluLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkaW4ucmVzdW1lKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4aXRDb2RlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBmYWlsIGlmIG5vIHNwZWNzIHdlcmUgZm91bmQgb3Igc3BlY2lmaWVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKHRoaXMuc2NoZWR1bGUpLnJlZHVjZSgoc3BlY0NudCwgc2NoZWR1bGUpID0+IHNwZWNDbnQgKyBzY2hlZHVsZS5zcGVjcy5sZW5ndGgsIDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdObyBzcGVjcyBmb3VuZCB0byBydW4sIGV4aXRpbmcgd2l0aCBmYWlsdXJlJylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybiBpbW1lZGlhdGVseSBpZiBubyBzcGVjIHdhcyBydW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuU3BlY3MoKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvKipcbiAgICAgICAgICogcnVuIG9uQ29tcGxldGUgaG9va1xuICAgICAgICAgKi9cbiAgICAgICAgbG9nLmluZm8oJ1J1biBvbkNvbXBsZXRlIGhvb2snKVxuICAgICAgICBhd2FpdCBydW5TZXJ2aWNlSG9vayhsYXVuY2hlciwgJ29uQ29tcGxldGUnLCBleGl0Q29kZSwgY29uZmlnLCBjYXBzKVxuICAgICAgICBhd2FpdCBjb25maWcub25Db21wbGV0ZShleGl0Q29kZSwgY29uZmlnLCBjYXBzKVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLnVwZGF0ZVZpZXcoKVxuICAgICAgICByZXR1cm4gZXhpdENvZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gbXVsdGlwbGUgc2luZ2xlIHJlbW90ZSB0ZXN0c1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYWxsIHNwZWNzIGhhdmUgYmVlbiBydW4gYW5kIGFsbCBpbnN0YW5jZXMgaGF2ZSBmaW5pc2hlZFxuICAgICAqL1xuICAgIHJ1blNwZWNzICgpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3Agc3Bhd25pbmcgbmV3IHByb2Nlc3NlcyB3aGVuIENUUkwrQyB3YXMgdHJpZ2dlcmVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5oYXNUcmlnZ2VyZWRFeGl0Um91dGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpIDwgY29uZmlnLm1heEluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IHNjaGVkdWxhYmxlQ2FwcyA9IHRoaXMuc2NoZWR1bGVcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBiYWlsIGlmIG51bWJlciBvZiBlcnJvcnMgZXhjZWVkcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHR5cGVvZiBjb25maWcuYmFpbCAhPT0gJ251bWJlcicgfHwgY29uZmlnLmJhaWwgPCAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5iYWlsID4gdGhpcy5ydW5uZXJGYWlsZWRcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogY2xlYXIgbnVtYmVyIG9mIHNwZWNzIHdoZW4gZmlsdGVyIGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZS5mb3JFYWNoKCh0KSA9PiB7IHQuc3BlY3MgPSBbXSB9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogbWFrZSBzdXJlIGNvbXBsZXRlIG51bWJlciBvZiBydW5uaW5nIGluc3RhbmNlcyBpcyBub3QgaGlnaGVyIHRoYW4gZ2VuZXJhbCBtYXhJbnN0YW5jZXMgbnVtYmVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoKSA9PiB0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpIDwgY29uZmlnLm1heEluc3RhbmNlcylcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBtYWtlIHN1cmUgdGhlIGNhcGFiaWxpdHkgaGFzIGF2YWlsYWJsZSBjYXBhY2l0aWVzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYS5hdmFpbGFibGVJbnN0YW5jZXMgPiAwKVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG1ha2Ugc3VyZSBjYXBhYmlsaXR5IGhhcyBzdGlsbCBjYXBzIHRvIHJ1blxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGEpID0+IGEuc3BlY3MubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBtYWtlIHN1cmUgd2UgYXJlIHJ1bm5pbmcgY2FwcyB3aXRoIGxlc3MgcnVubmluZyBpbnN0YW5jZXMgZmlyc3RcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5ydW5uaW5nSW5zdGFuY2VzID4gYi5ydW5uaW5nSW5zdGFuY2VzKVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGNvbnRpbnVlIGlmIG5vIGNhcGFiaWxpdHkgd2VyZSBzY2hlZHVsYWJsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2NoZWR1bGFibGVDYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBbc2NoZWR1bGFibGVDYXBzWzBdLnNwZWNzLnNoaWZ0KCldLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5jYXBzLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5jaWQsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGFibGVDYXBzWzBdLnNlbGVuaXVtU2VydmVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBzY2hlZHVsYWJsZUNhcHNbMF0uYXZhaWxhYmxlSW5zdGFuY2VzLS1cbiAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5ydW5uaW5nSW5zdGFuY2VzKytcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlck9mUnVubmluZ0luc3RhbmNlcygpID09PSAwICYmIHRoaXMuZ2V0TnVtYmVyT2ZTcGVjc0xlZnQoKSA9PT0gMFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldHMgbnVtYmVyIG9mIGFsbCBydW5uaW5nIGluc3RhbmNlc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gbnVtYmVyIG9mIHJ1bm5pbmcgaW5zdGFuY2VzXG4gICAgICovXG4gICAgZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUubWFwKChhKSA9PiBhLnJ1bm5pbmdJbnN0YW5jZXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiB0b3RhbCBzcGVjcyBsZWZ0IHRvIGNvbXBsZXRlIHdob2xlIHN1aXRlc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gc3BlY3MgbGVmdCB0byBjb21wbGV0ZSBzdWl0ZVxuICAgICAqL1xuICAgIGdldE51bWJlck9mU3BlY3NMZWZ0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGUubWFwKChhKSA9PiBhLnNwZWNzLmxlbmd0aCkucmVkdWNlKChhLCBiKSA9PiBhICsgYilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBpbnN0YW5jZSBpbiBhIGNoaWxkIHByb2Nlc3MuXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHNwZWNzICBTcGVjcyB0byBydW5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNpZCAgQ2FwYWJpbGl0aWVzIElEXG4gICAgICovXG4gICAgc3RhcnRJbnN0YW5jZSAoc3BlY3MsIGNhcHMsIGNpZCwgc2VydmVyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRDb25maWcoKVxuICAgICAgICBjaWQgPSB0aGlzLmdldFJ1bm5lcklkKGNpZClcbiAgICAgICAgbGV0IHByb2Nlc3NOdW1iZXIgPSB0aGlzLnJ1bm5lclN0YXJ0ZWQgKyAxXG5cbiAgICAgICAgLy8gcHJvY2Vzcy5kZWJ1Z1BvcnQgZGVmYXVsdHMgdG8gNTg1OCBhbmQgaXMgc2V0IGV2ZW4gd2hlbiBwcm9jZXNzXG4gICAgICAgIC8vIGlzIG5vdCBiZWluZyBkZWJ1Z2dlZC5cbiAgICAgICAgbGV0IGRlYnVnQXJncyA9IFtdXG4gICAgICAgIGxldCBkZWJ1Z1R5cGVcbiAgICAgICAgbGV0IGRlYnVnSG9zdCA9ICcnXG4gICAgICAgIGxldCBkZWJ1Z1BvcnQgPSBwcm9jZXNzLmRlYnVnUG9ydFxuICAgICAgICBmb3IgKGxldCBpIGluIHByb2Nlc3MuZXhlY0FyZ3YpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnQXJncyA9IHByb2Nlc3MuZXhlY0FyZ3ZbaV0ubWF0Y2goJy0tKGRlYnVnfGluc3BlY3QpKD86LWJyayk/KD86PSguKik6KT8nKVxuICAgICAgICAgICAgaWYgKGRlYnVnQXJncykge1xuICAgICAgICAgICAgICAgIGxldCBbLCB0eXBlLCBob3N0XSA9IGRlYnVnQXJnc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnVHlwZSA9IHR5cGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdIb3N0ID0gYCR7aG9zdH06YFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1Z1R5cGUpIHtcbiAgICAgICAgICAgIGRlYnVnQXJncy5wdXNoKGAtLSR7ZGVidWdUeXBlfT0ke2RlYnVnSG9zdH0keyhkZWJ1Z1BvcnQgKyBwcm9jZXNzTnVtYmVyKX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgeW91IHdvdWxkIGxpa2UgdG8gYWRkIC0tZGVidWctYnJrLCB1c2UgYSBkaWZmZXJlbnQgcG9ydCwgZXRjLi4uXG4gICAgICAgIGxldCBjYXBFeGVjQXJncyA9IFtcbiAgICAgICAgICAgIC4uLihjb25maWcuZXhlY0FyZ3YgfHwgW10pLFxuICAgICAgICAgICAgLi4uKGNhcHMuZXhlY0FyZ3YgfHwgW10pXG4gICAgICAgIF1cblxuICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgY2hpbGQuZm9yayBleGVjQXJncyBpcyBwcm9jZXNzLmV4ZWNBcmdzLFxuICAgICAgICAvLyBzbyBjb250aW51ZSB0byB1c2UgdGhpcyB1bmxlc3MgYW5vdGhlciB2YWx1ZSBpcyBzcGVjaWZpZWQgaW4gY29uZmlnLlxuICAgICAgICBsZXQgZGVmYXVsdEFyZ3MgPSAoY2FwRXhlY0FyZ3MubGVuZ3RoKSA/IHByb2Nlc3MuZXhlY0FyZ3YgOiBbXVxuXG4gICAgICAgIC8vIElmIGFuIGFyZyBhcHBlYXJzIG11bHRpcGxlIHRpbWVzIHRoZSBsYXN0IG9jY3VycmVuY2UgaXMgdXNlZFxuICAgICAgICBsZXQgZXhlY0FyZ3YgPSBbIC4uLmRlZmF1bHRBcmdzLCAuLi5kZWJ1Z0FyZ3MsIC4uLmNhcEV4ZWNBcmdzIF1cblxuICAgICAgICAvLyBwcmVmZXIgbGF1bmNoZXIgc2V0dGluZ3MgaW4gY2FwYWJpbGl0aWVzIG92ZXIgZ2VuZXJhbCBsYXVuY2hlclxuICAgICAgICB0aGlzLnJ1bm5lci5ydW4oe1xuICAgICAgICAgICAgY2lkLFxuICAgICAgICAgICAgY29tbWFuZDogJ3J1bicsXG4gICAgICAgICAgICBjb25maWdGaWxlOiB0aGlzLmNvbmZpZ0ZpbGUsXG4gICAgICAgICAgICBhcmd2OiB0aGlzLmFyZ3YsXG4gICAgICAgICAgICBjYXBzLFxuICAgICAgICAgICAgcHJvY2Vzc051bWJlcixcbiAgICAgICAgICAgIHNwZWNzLFxuICAgICAgICAgICAgc2VydmVyLFxuICAgICAgICAgICAgaXNNdWx0aXJlbW90ZTogdGhpcy5pc011bHRpcmVtb3RlLFxuICAgICAgICAgICAgZXhlY0FyZ3ZcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmludGVyZmFjZS5lbWl0KCdqb2I6c3RhcnQnLCB7IGNpZCwgY2Fwcywgc3BlY3MgfSlcbiAgICAgICAgdGhpcy5ydW5uZXJTdGFydGVkKytcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZXMgYSBydW5uZXIgaWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNpZCBjYXBhYmlsaXR5IGlkICh1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBjYXBhYmlsaXR5KVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIHJ1bm5lciBpZCAoY29tYmluYXRpb24gb2YgY2lkIGFuZCB0ZXN0IGlkIGUuZy4gMGEsIDBiLCAxYSwgMWIgLi4uKVxuICAgICAqL1xuICAgIGdldFJ1bm5lcklkIChjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJpZFtjaWRdKSB7XG4gICAgICAgICAgICB0aGlzLnJpZFtjaWRdID0gMFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtjaWR9LSR7dGhpcy5yaWRbY2lkXSsrfWBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0ZXN0IHJ1bm5lciBwcm9jZXNzIG9uY2UgYWxsIGNoaWxkIHByb2Nlc3NlcyBoYXZlIGV4aXRlZFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2lkICAgICAgIENhcGFiaWxpdGllcyBJRFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZXhpdENvZGUgIGV4aXQgY29kZSBvZiBjaGlsZCBwcm9jZXNzXG4gICAgICovXG4gICAgZW5kSGFuZGxlciAoeyBjaWQsIGV4aXRDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgcGFzc2VkID0gZXhpdENvZGUgPT09IDBcbiAgICAgICAgdGhpcy5leGl0Q29kZSA9IHRoaXMuZXhpdENvZGUgfHwgZXhpdENvZGVcbiAgICAgICAgdGhpcy5ydW5uZXJGYWlsZWQgKz0gIXBhc3NlZCA/IDEgOiAwXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLmVtaXQoJ2pvYjplbmQnLCB7IGNpZCwgcGFzc2VkIH0pXG5cbiAgICAgICAgLy8gVXBkYXRlIHNjaGVkdWxlIG5vdyB0aGlzIHByb2Nlc3MgaGFzIGVuZGVkXG4gICAgICAgIGlmICghdGhpcy5pc011bHRpcmVtb3RlKSB7XG4gICAgICAgICAgICAvLyBnZXQgY2lkIChjYXBhYmlsaXR5IGlkKSBmcm9tIHJpZCAocnVubmVyIGlkKVxuICAgICAgICAgICAgY2lkID0gcGFyc2VJbnQoY2lkLCAxMClcblxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVtjaWRdLmF2YWlsYWJsZUluc3RhbmNlcysrXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlW2NpZF0ucnVubmluZ0luc3RhbmNlcy0tXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aXJlbW90ZSAmJiAhdGhpcy5ydW5TcGVjcygpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzb2x2ZSh0aGlzLmV4aXRDb2RlKSwgMTAwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaW5pc2ggd2l0aCBleGl0IGNvZGUgMVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UudXBkYXRlVmlldygpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVzb2x2ZSgxKSwgMTAwKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSBhbGwgc3RhcnRlZCBzZWxlbml1bSBzZXNzaW9ucyBnZXQgY2xvc2VkIHByb3Blcmx5IGFuZCBwcmV2ZW50XG4gICAgICogaGF2aW5nIGRlYWQgZHJpdmVyIHByb2Nlc3Nlcy4gVG8gZG8gc28gbGV0IHRoZSBydW5uZXIgZW5kIGl0cyBTZWxlbml1bVxuICAgICAqIHNlc3Npb24gZmlyc3QgYmVmb3JlIGtpbGxpbmdcbiAgICAgKi9cbiAgICBleGl0SGFuZGxlciAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lIHx8ICF0aGlzLmhhc1N0YXJ0ZWRBbnlQcm9jZXNzKSB7XG4gICAgICAgICAgICBsb2cubG9nKCdcXG5LaWxsaW5nIHByb2Nlc3MsIGJ5ZSEnKVxuXG4gICAgICAgICAgICAvLyBXaGVuIHNwYXduZWQgYXMgYSBzdWJwcm9jZXNzLFxuICAgICAgICAgICAgLy8gU0lHSU5UIHdpbGwgbm90IGJlIGZvcndhcmRlZCB0byBjaGlsZHMuXG4gICAgICAgICAgICAvLyBUaHVzIGZvciB0aGUgY2hpbGQgdG8gZXhpdCBjbGVhbmx5LCB3ZSBtdXN0IGZvcmNlIHNlbmQgU0lHSU5UXG4gICAgICAgICAgICBpZiAoIXByb2Nlc3Muc3RkaW4uaXNUVFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5lci5raWxsKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluaXNoIHdpdGggZXhpdCBjb2RlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmUoMSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gc3Bhd25lZCBhcyBhIHN1YnByb2Nlc3MsXG4gICAgICAgIC8vIFNJR0lOVCB3aWxsIG5vdCBiZSBmb3J3YXJkZWQgdG8gY2hpbGRzLlxuICAgICAgICAvLyBUaHVzIGZvciB0aGUgY2hpbGQgdG8gZXhpdCBjbGVhbmx5LCB3ZSBtdXN0IGZvcmNlIHNlbmQgU0lHSU5UXG4gICAgICAgIGlmICghcHJvY2Vzcy5zdGRpbi5pc1RUWSkge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIua2lsbCgpXG4gICAgICAgIH1cblxuICAgICAgICBsb2cubG9nKGBcblxuRW5kIHNlbGVuaXVtIHNlc3Npb25zIHByb3Blcmx5IC4uLlxuKHByZXNzIGN0cmwrYyBhZ2FpbiB0byBoYXJkIGtpbGwgdGhlIHJ1bm5lcilcbmApXG5cbiAgICAgICAgdGhpcy5oYXNUcmlnZ2VyZWRFeGl0Um91dGluZSA9IHRydWVcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExhdW5jaGVyXG4iXX0=