'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sourceMapSupport2 = require('source-map-support');

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _cliSpinners = require('cli-spinners');

var _cliSpinners2 = _interopRequireDefault(_cliSpinners);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _wdioInterface = require('wdio-interface');

var _wdioInterface2 = _interopRequireDefault(_wdioInterface);

var _wdioLogger = require('wdio-logger');

var _wdioLogger2 = _interopRequireDefault(_wdioLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _sourceMapSupport2.install)();


const log = (0, _wdioLogger2.default)('wdio-cli');

const clockSpinner = _cliSpinners2.default['clock'];

class WDIOCLInterface extends _events2.default {
    constructor(config, specs) {
        super();
        this.hasAnsiSupport = !!_chalk2.default.supportsColor.hasBasic;
        this.clockTimer = 0;
        this.specs = specs;
        this.config = config;
        this.jobs = new Map();
        this.start = Date.now();
        this.result = {
            finished: 0,
            passed: 0,
            failed: 0
        };
        this.messages = {
            reporter: {}
        };

        this.interface = new _wdioInterface2.default();
        this.on('job:start', this.addJob.bind(this));
        this.on('job:end', this.clearJob.bind(this));
    }

    /**
     * add job to interface
     */
    addJob({ cid, caps, specs }) {
        this.jobs.set(cid, { caps, specs });
        this.updateView();
    }

    /**
     * clear job from interface
     */
    clearJob({ cid, passed }) {
        this.jobs.delete(cid);
        this.result.finished++;

        if (passed) {
            this.result.passed++;
        } else {
            this.result.failed++;
        }

        this.updateView(true);
    }

    /**
     * event handler that is triggered when runner sends up events
     */
    onMessage(params) {
        if (!params.origin || !this.messages[params.origin]) {
            return log.warn(`Can't identify message from worker: ${JSON.stringify(params)}, ignoring!`);
        }

        if (!this.messages[params.origin][params.name]) {
            this.messages[params.origin][params.name] = [];
        }
        this.messages[params.origin][params.name].push(params.content);
    }

    updateView(wasJobCleared) {
        const isFinished = this.jobs.size === 0;
        const pendingJobs = this.specs.length - this.jobs.size - this.result.finished;

        /**
         * check if environment supports ansi and print a limited update if not
         */
        if (!this.hasAnsiSupport && !isFinished) {
            /**
             * only update if a job finishes
             */
            if (!wasJobCleared) {
                return;
            }

            const clockSpinnerSymbol = this.getClockSymbol();
            return this.interface.log(`${clockSpinnerSymbol} ` + `${this.jobs.size} running, ` + `${this.result.passed} passed, ` + `${this.result.failed} failed, ` + `${this.specs.length} total ` + `(${Math.round(this.result.finished / this.specs.length * 100)}% completed)`);
        }

        this.interface.clearAll();
        this.interface.log();

        /**
         * print reporter output
         */
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Object.entries(this.messages.reporter)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                const _ref = _step.value;

                var _ref2 = _slicedToArray(_ref, 2);

                const reporterName = _ref2[0];
                const messages = _ref2[1];

                this.interface.log(_chalk2.default.bgYellow.black(`"${reporterName}" Reporter:`));
                this.interface.log(messages.join(''));
                this.interface.log();
            }

            /**
             * print running jobs
             */
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = this.jobs.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                const _ref3 = _step2.value;

                var _ref4 = _slicedToArray(_ref3, 2);

                const cid = _ref4[0];
                const job = _ref4[1];

                const filename = job.specs.join(', ').replace(process.cwd(), '');
                this.interface.log(_chalk2.default.bgYellow.black(' RUNNING '), cid, 'in', job.caps.browserName, '-', filename);
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        if (pendingJobs) {
            this.interface.log(_chalk2.default.yellow('...', pendingJobs, 'pending tests'));
        }

        /**
         * print stdout and stderr from runners
         */
        if (isFinished) {
            if (this.interface.stdoutBuffer.length) {
                this.interface.log(_chalk2.default.bgYellow.black(`Stdout:\n`) + this.interface.stdoutBuffer.join(''));
            }
            if (this.interface.stderrBuffer.length) {
                this.interface.log(_chalk2.default.bgRed.black(`Stderr:\n`) + this.interface.stderrBuffer.join(''));
            }
        }

        /**
         * add empty line between "pending tests" and results
         */
        if (this.jobs.size) {
            this.interface.log();
        }

        this.interface.log('Test Suites:\t', _chalk2.default.green(this.result.passed, 'passed') + ', ' + (this.result.failed ? _chalk2.default.red(this.result.failed, 'failed') + ', ' : '') + this.specs.length, 'total', `(${this.specs.length ? Math.round(this.result.finished / this.specs.length * 100) : 0}% completed)`);

        this.updateClock();

        if (isFinished) {
            clearTimeout(this.interval);
            this.interface.log('\n');
        }
    }

    updateClock(interval = 100) {
        const clockSpinnerSymbol = this.getClockSymbol();

        clearTimeout(this.interval);
        this.interface.clearLine();
        this.interface.write('Time:\t\t ' + clockSpinnerSymbol + ' ' + ((Date.now() - this.start) / 1000).toFixed(2) + 's');
        this.interval = setTimeout(() => this.updateClock(interval), interval);
    }

    getClockSymbol() {
        return clockSpinner.frames[this.clockTimer = ++this.clockTimer % clockSpinner.frames.length];
    }
}
exports.default = WDIOCLInterface;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnRlcmZhY2UuanMiXSwibmFtZXMiOlsibG9nIiwiY2xvY2tTcGlubmVyIiwiY2xpU3Bpbm5lcnMiLCJXRElPQ0xJbnRlcmZhY2UiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsInNwZWNzIiwiaGFzQW5zaVN1cHBvcnQiLCJjaGFsayIsInN1cHBvcnRzQ29sb3IiLCJoYXNCYXNpYyIsImNsb2NrVGltZXIiLCJqb2JzIiwiTWFwIiwic3RhcnQiLCJEYXRlIiwibm93IiwicmVzdWx0IiwiZmluaXNoZWQiLCJwYXNzZWQiLCJmYWlsZWQiLCJtZXNzYWdlcyIsInJlcG9ydGVyIiwiaW50ZXJmYWNlIiwiQ0xJbnRlcmZhY2UiLCJvbiIsImFkZEpvYiIsImNsZWFySm9iIiwiY2lkIiwiY2FwcyIsInNldCIsInVwZGF0ZVZpZXciLCJkZWxldGUiLCJvbk1lc3NhZ2UiLCJwYXJhbXMiLCJvcmlnaW4iLCJ3YXJuIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUiLCJwdXNoIiwiY29udGVudCIsIndhc0pvYkNsZWFyZWQiLCJpc0ZpbmlzaGVkIiwic2l6ZSIsInBlbmRpbmdKb2JzIiwibGVuZ3RoIiwiY2xvY2tTcGlubmVyU3ltYm9sIiwiZ2V0Q2xvY2tTeW1ib2wiLCJNYXRoIiwicm91bmQiLCJjbGVhckFsbCIsIk9iamVjdCIsImVudHJpZXMiLCJyZXBvcnRlck5hbWUiLCJiZ1llbGxvdyIsImJsYWNrIiwiam9pbiIsImpvYiIsImZpbGVuYW1lIiwicmVwbGFjZSIsInByb2Nlc3MiLCJjd2QiLCJicm93c2VyTmFtZSIsInllbGxvdyIsInN0ZG91dEJ1ZmZlciIsInN0ZGVyckJ1ZmZlciIsImJnUmVkIiwiZ3JlZW4iLCJyZWQiLCJ1cGRhdGVDbG9jayIsImNsZWFyVGltZW91dCIsImludGVydmFsIiwiY2xlYXJMaW5lIiwid3JpdGUiLCJ0b0ZpeGVkIiwic2V0VGltZW91dCIsImZyYW1lcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7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LENBQUNoQyxLQUFLQyxHQUFMLEtBQWEsS0FBS0YsS0FBbkIsSUFBNEIsSUFBN0IsRUFBbUM2RCxPQUFuQyxDQUEyQyxDQUEzQyxDQUExQyxHQUEwRixHQUEvRztBQUNBLGFBQUtILFFBQUwsR0FBZ0JJLFdBQVcsTUFBTSxLQUFLTixXQUFMLENBQWlCRSxRQUFqQixDQUFqQixFQUE2Q0EsUUFBN0MsQ0FBaEI7QUFDSDs7QUFFRHhCLHFCQUFrQjtBQUNkLGVBQU9oRCxhQUFhNkUsTUFBYixDQUFvQixLQUFLbEUsVUFBTCxHQUFrQixFQUFFLEtBQUtBLFVBQVAsR0FBb0JYLGFBQWE2RSxNQUFiLENBQW9CL0IsTUFBOUUsQ0FBUDtBQUNIO0FBM0pxRDtrQkFBckM1QyxlIiwiZmlsZSI6ImludGVyZmFjZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGFsayBmcm9tICdjaGFsaydcbmltcG9ydCBjbGlTcGlubmVycyBmcm9tICdjbGktc3Bpbm5lcnMnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cydcbmltcG9ydCBDTEludGVyZmFjZSBmcm9tICd3ZGlvLWludGVyZmFjZSdcbmltcG9ydCBsb2dnZXIgZnJvbSAnd2Rpby1sb2dnZXInXG5cbmNvbnN0IGxvZyA9IGxvZ2dlcignd2Rpby1jbGknKVxuXG5jb25zdCBjbG9ja1NwaW5uZXIgPSBjbGlTcGlubmVyc1snY2xvY2snXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXRElPQ0xJbnRlcmZhY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yIChjb25maWcsIHNwZWNzKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5oYXNBbnNpU3VwcG9ydCA9ICEhY2hhbGsuc3VwcG9ydHNDb2xvci5oYXNCYXNpY1xuICAgICAgICB0aGlzLmNsb2NrVGltZXIgPSAwXG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjc1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xuICAgICAgICB0aGlzLmpvYnMgPSBuZXcgTWFwKClcbiAgICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KClcbiAgICAgICAgdGhpcy5yZXN1bHQgPSB7XG4gICAgICAgICAgICBmaW5pc2hlZDogMCxcbiAgICAgICAgICAgIHBhc3NlZDogMCxcbiAgICAgICAgICAgIGZhaWxlZDogMFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAgICAgICByZXBvcnRlcjoge31cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlID0gbmV3IENMSW50ZXJmYWNlKClcbiAgICAgICAgdGhpcy5vbignam9iOnN0YXJ0JywgOjp0aGlzLmFkZEpvYilcbiAgICAgICAgdGhpcy5vbignam9iOmVuZCcsIDo6dGhpcy5jbGVhckpvYilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgam9iIHRvIGludGVyZmFjZVxuICAgICAqL1xuICAgIGFkZEpvYih7IGNpZCwgY2Fwcywgc3BlY3MgfSkge1xuICAgICAgICB0aGlzLmpvYnMuc2V0KGNpZCwgeyBjYXBzLCBzcGVjcyB9KVxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsZWFyIGpvYiBmcm9tIGludGVyZmFjZVxuICAgICAqL1xuICAgIGNsZWFySm9iICh7IGNpZCwgcGFzc2VkIH0pIHtcbiAgICAgICAgdGhpcy5qb2JzLmRlbGV0ZShjaWQpXG4gICAgICAgIHRoaXMucmVzdWx0LmZpbmlzaGVkKytcblxuICAgICAgICBpZiAocGFzc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wYXNzZWQrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkKytcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmlldyh0cnVlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGV2ZW50IGhhbmRsZXIgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiBydW5uZXIgc2VuZHMgdXAgZXZlbnRzXG4gICAgICovXG4gICAgb25NZXNzYWdlIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMub3JpZ2luIHx8ICF0aGlzLm1lc3NhZ2VzW3BhcmFtcy5vcmlnaW5dKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nLndhcm4oYENhbid0IGlkZW50aWZ5IG1lc3NhZ2UgZnJvbSB3b3JrZXI6ICR7SlNPTi5zdHJpbmdpZnkocGFyYW1zKX0sIGlnbm9yaW5nIWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWVzc2FnZXNbcGFyYW1zLm9yaWdpbl1bcGFyYW1zLm5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzW3BhcmFtcy5vcmlnaW5dW3BhcmFtcy5uYW1lXSA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlc1twYXJhbXMub3JpZ2luXVtwYXJhbXMubmFtZV0ucHVzaChwYXJhbXMuY29udGVudClcbiAgICB9XG5cbiAgICB1cGRhdGVWaWV3ICh3YXNKb2JDbGVhcmVkKSB7XG4gICAgICAgIGNvbnN0IGlzRmluaXNoZWQgPSB0aGlzLmpvYnMuc2l6ZSA9PT0gMFxuICAgICAgICBjb25zdCBwZW5kaW5nSm9icyA9IHRoaXMuc3BlY3MubGVuZ3RoIC0gdGhpcy5qb2JzLnNpemUgLSB0aGlzLnJlc3VsdC5maW5pc2hlZFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiBlbnZpcm9ubWVudCBzdXBwb3J0cyBhbnNpIGFuZCBwcmludCBhIGxpbWl0ZWQgdXBkYXRlIGlmIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmhhc0Fuc2lTdXBwb3J0ICYmICFpc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG9ubHkgdXBkYXRlIGlmIGEgam9iIGZpbmlzaGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghd2FzSm9iQ2xlYXJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbG9ja1NwaW5uZXJTeW1ib2wgPSB0aGlzLmdldENsb2NrU3ltYm9sKClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyZmFjZS5sb2coXG4gICAgICAgICAgICAgICAgYCR7Y2xvY2tTcGlubmVyU3ltYm9sfSBgICtcbiAgICAgICAgICAgICAgICBgJHt0aGlzLmpvYnMuc2l6ZX0gcnVubmluZywgYCArXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5yZXN1bHQucGFzc2VkfSBwYXNzZWQsIGAgK1xuICAgICAgICAgICAgICAgIGAke3RoaXMucmVzdWx0LmZhaWxlZH0gZmFpbGVkLCBgICtcbiAgICAgICAgICAgICAgICBgJHt0aGlzLnNwZWNzLmxlbmd0aH0gdG90YWwgYCArXG4gICAgICAgICAgICAgICAgYCgke01hdGgucm91bmQoKHRoaXMucmVzdWx0LmZpbmlzaGVkIC8gdGhpcy5zcGVjcy5sZW5ndGgpICogMTAwKX0lIGNvbXBsZXRlZClgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnRlcmZhY2UuY2xlYXJBbGwoKVxuICAgICAgICB0aGlzLmludGVyZmFjZS5sb2coKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmludCByZXBvcnRlciBvdXRwdXRcbiAgICAgICAgICovXG4gICAgICAgIGZvciAoY29uc3QgW3JlcG9ydGVyTmFtZSwgbWVzc2FnZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubWVzc2FnZXMucmVwb3J0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZS5sb2coY2hhbGsuYmdZZWxsb3cuYmxhY2soYFwiJHtyZXBvcnRlck5hbWV9XCIgUmVwb3J0ZXI6YCkpXG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZS5sb2cobWVzc2FnZXMuam9pbignJykpXG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZS5sb2coKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByaW50IHJ1bm5pbmcgam9ic1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChjb25zdCBbY2lkLCBqb2JdIG9mIHRoaXMuam9icy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gam9iLnNwZWNzLmpvaW4oJywgJykucmVwbGFjZShwcm9jZXNzLmN3ZCgpLCAnJylcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmxvZyhjaGFsay5iZ1llbGxvdy5ibGFjaygnIFJVTk5JTkcgJyksIGNpZCwgJ2luJywgam9iLmNhcHMuYnJvd3Nlck5hbWUsICctJywgZmlsZW5hbWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVuZGluZ0pvYnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmxvZyhjaGFsay55ZWxsb3coJy4uLicsIHBlbmRpbmdKb2JzLCAncGVuZGluZyB0ZXN0cycpKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByaW50IHN0ZG91dCBhbmQgc3RkZXJyIGZyb20gcnVubmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyZmFjZS5zdGRvdXRCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UubG9nKGNoYWxrLmJnWWVsbG93LmJsYWNrKGBTdGRvdXQ6XFxuYCkgKyB0aGlzLmludGVyZmFjZS5zdGRvdXRCdWZmZXIuam9pbignJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcmZhY2Uuc3RkZXJyQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmxvZyhjaGFsay5iZ1JlZC5ibGFjayhgU3RkZXJyOlxcbmApICsgdGhpcy5pbnRlcmZhY2Uuc3RkZXJyQnVmZmVyLmpvaW4oJycpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZCBlbXB0eSBsaW5lIGJldHdlZW4gXCJwZW5kaW5nIHRlc3RzXCIgYW5kIHJlc3VsdHNcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmpvYnMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UubG9nKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLmxvZyhcbiAgICAgICAgICAgICdUZXN0IFN1aXRlczpcXHQnLCBjaGFsay5ncmVlbih0aGlzLnJlc3VsdC5wYXNzZWQsICdwYXNzZWQnKSArICcsICcgK1xuICAgICAgICAgICAgKHRoaXMucmVzdWx0LmZhaWxlZCA/IGNoYWxrLnJlZCh0aGlzLnJlc3VsdC5mYWlsZWQsICdmYWlsZWQnKSArICcsICcgOiAnJykgK1xuICAgICAgICAgICAgdGhpcy5zcGVjcy5sZW5ndGgsICd0b3RhbCcsXG4gICAgICAgICAgICBgKCR7dGhpcy5zcGVjcy5sZW5ndGggPyBNYXRoLnJvdW5kKCh0aGlzLnJlc3VsdC5maW5pc2hlZCAvIHRoaXMuc3BlY3MubGVuZ3RoKSAqIDEwMCkgOiAwfSUgY29tcGxldGVkKWBcbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMudXBkYXRlQ2xvY2soKVxuXG4gICAgICAgIGlmIChpc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnRlcnZhbClcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmxvZygnXFxuJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUNsb2NrIChpbnRlcnZhbCA9IDEwMCkge1xuICAgICAgICBjb25zdCBjbG9ja1NwaW5uZXJTeW1ib2wgPSB0aGlzLmdldENsb2NrU3ltYm9sKClcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbnRlcnZhbClcbiAgICAgICAgdGhpcy5pbnRlcmZhY2UuY2xlYXJMaW5lKClcbiAgICAgICAgdGhpcy5pbnRlcmZhY2Uud3JpdGUoJ1RpbWU6XFx0XFx0ICcgKyBjbG9ja1NwaW5uZXJTeW1ib2wgKyAnICcgKyAoKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0KSAvIDEwMDApLnRvRml4ZWQoMikgKyAncycpXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlQ2xvY2soaW50ZXJ2YWwpLCBpbnRlcnZhbClcbiAgICB9XG5cbiAgICBnZXRDbG9ja1N5bWJvbCAoKSB7XG4gICAgICAgIHJldHVybiBjbG9ja1NwaW5uZXIuZnJhbWVzW3RoaXMuY2xvY2tUaW1lciA9ICsrdGhpcy5jbG9ja1RpbWVyICUgY2xvY2tTcGlubmVyLmZyYW1lcy5sZW5ndGhdXG4gICAgfVxufVxuIl19